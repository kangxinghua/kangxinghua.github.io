<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Spring Cloud 使用概述]]></title>
      <url>http://kxh.ink/2018/11/12/spring-cloud-principle/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>毫无疑问，Spring Cloud是目前微服务架构领域的翘楚，无数的书籍博客都在讲解这个技术。不过大多数讲解还停留在对Spring Cloud功能使用的层面，其底层的很多原理，很多人可能并不知晓。因此本文将通过大量的手绘图，给大家谈谈Spring Cloud微服务架构的底层原理。</p>
<p>实际上，Spring Cloud是一个全家桶式的技术栈，包含了很多组件。本文先从其最核心的几个组件入手，来剖析一下其底层的工作原理。也就是Eureka、Ribbon、Feign、Hystrix、Zuul这几个组件</p>
<a id="more"></a>
<h2 id="业务场景介绍"><a href="#业务场景介绍" class="headerlink" title="业务场景介绍"></a>业务场景介绍</h2><p>先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：</p>
<ul>
<li>创建一个订单后，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”</li>
<li>扣减相应的商品库存</li>
<li>通知仓储中心，进行发货</li>
<li>给用户的这次购物增加相应的积分</li>
</ul>
<p>针对上述流程，我们需要有<strong>订单服务</strong>、<strong>库存服务</strong>、<strong>仓储服务</strong>、<strong>积分服务</strong>。整个流程的大体思路如下：</p>
<ul>
<li>用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态</li>
<li>订单服务调用库存服务，完成相应功能</li>
<li>订单服务调用仓储服务，完成相应功能</li>
<li>订单服务调用积分服务，完成相应功能</li>
</ul>
<p><strong>至此，整个支付订单的业务流程结束</strong></p>
<p>下图这张图，清晰表明了各服务间的调用过程：</p>
<p><img src="166ebffb48c481a3" alt=""></p>
<p>好！有了业务场景之后，咱们就一起来看看Spring Cloud微服务架构中，这几个组件如何相互协作，各自发挥的作用以及其背后的原理</p>
<h2 id="Spring-Cloud核心组件：Eureka"><a href="#Spring-Cloud核心组件：Eureka" class="headerlink" title="Spring Cloud核心组件：Eureka"></a>Spring Cloud核心组件：Eureka</h2><p><strong>咱们来考虑第一个问题：</strong> 订单服务想要调用库存服务、仓储服务，或者积分服务，怎么调用？</p>
<ul>
<li>订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，都不知道发送给谁，有心无力！</li>
<li>这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。</li>
</ul>
<p>咱们来看看下面的这张图，结合图来仔细剖析一下整个流程：</p>
<p><img src="166ebffcb7ce31b8" alt=""></p>
<p>如上图所示，库存服务、仓储服务、积分服务中都有一个<strong>Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中。</strong>说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而<strong>Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号</strong></p>
<p>订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的注册表中拉取到自己本地缓存起来</p>
<p>这时如果订单服务想要调用库存服务，不就可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。</p>
<p>总结一下：</p>
<ul>
<li><strong>Eureka Client：</strong> 负责将这个服务的信息注册到Eureka Server中</li>
<li><strong>Eureka Server：</strong> 注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号</li>
</ul>
<h2 id="Spring-Cloud核心组件：Feign"><a href="#Spring-Cloud核心组件：Feign" class="headerlink" title="Spring Cloud核心组件：Feign"></a>Spring Cloud核心组件：Feign</h2><p>现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了。<strong>但是新问题又来了：难道订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？</strong></p>
<p>这是上述流程翻译的代码片段，咱们一起来看看，体会一下这种绝望而无助的感受！！！</p>
<p><strong>友情提示，前方高能：</strong></p>
<p><img src="166ebced960f2024" alt=""></p>
<p>看完上面那一大段代码，有没有感到后背发凉、一身冷汗？实际上你进行服务间调用时，如果每次都手写代码，代码量比上面那段要多至少几倍，所以这个事压根儿就不是地球人能干的。</p>
<p>既然如此，那怎么办呢？别急，Feign早已为我们提供好了优雅的解决方案。来看看如果用Feign的话，你的订单服务调用库存服务的代码会变成啥样？</p>
<p><img src="166ebcf01b773dd4" alt=""></p>
<p>看完上面的代码什么感觉？是不是感觉整个世界都干净了，又找到了活下去的勇气！没有底层的建立连接、构造请求、解析响应的代码，直接就是用注解定义一个 FeignClient接口，然后调用那个接口就可以了。人家Feign Client会在底层根据你的注解，跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等。这一系列脏活累活，人家Feign全给你干了。</p>
<p>那么问题来了，Feign是如何做到这么神奇的呢？很简单，Feign的一个关键机制就是使用了动态代理。咱们一起来看看下面的图，结合图来分析：</p>
<ul>
<li>首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理</li>
<li>接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心</li>
<li>Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址</li>
<li>最后针对这个地址，发起请求、解析响应</li>
</ul>
<p><img src="166ebfff505b2a20" alt=""></p>
<h2 id="Spring-Cloud核心组件：Ribbon"><a href="#Spring-Cloud核心组件：Ribbon" class="headerlink" title="Spring Cloud核心组件：Ribbon"></a>Spring Cloud核心组件：Ribbon</h2><p>说完了Feign，还没完。现在新的问题又来了，如果人家库存服务部署在了5台机器上，如下所示：</p>
<ul>
<li>192.168.169:9000</li>
<li>192.168.170:9000</li>
<li>192.168.171:9000</li>
<li>192.168.172:9000</li>
<li>192.168.173:9000</li>
</ul>
<p><strong>这下麻烦了！人家Feign怎么知道该请求哪台机器呢？</strong></p>
<ul>
<li>这时Spring Cloud Ribbon就派上用场了。Ribbon就是专门解决这个问题的。它的作用是负载均衡，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上</li>
<li>Ribbon的负载均衡默认使用的最经典的Round Robin轮询算法。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推。</li>
</ul>
<p><strong>此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：</strong></p>
<ul>
<li>首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。</li>
<li>然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器</li>
<li>Feign就会针对这台机器，构造并发起请求。</li>
</ul>
<p>对上述整个过程，再来一张图，帮助大家更深刻的理解：</p>
<p><img src="166ec001dc155e98" alt=""></p>
<h2 id="Spring-Cloud核心组件：Hystrix"><a href="#Spring-Cloud核心组件：Hystrix" class="headerlink" title="Spring Cloud核心组件：Hystrix"></a>Spring Cloud核心组件：Hystrix</h2><p>在微服务架构里，一个系统会有很多的服务。以本文的业务场景为例：订单服务在一个业务流程里需要调用三个服务。现在假设订单服务自己最多只有100个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。</p>
<p><strong>咱们一起来分析一下，这样会导致什么问题？</strong></p>
<ul>
<li>如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程都会卡在请求积分服务这块。导致订单服务没有一个线程可以处理请求</li>
<li>然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求了</li>
</ul>
<p>上面这个，就是微服务架构中恐怖的服务雪崩问题，如下图所示：</p>
<p><img src="166ec0033f64a0a7" alt=""></p>
<p>如上图，这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。</p>
<p><strong>但是我们思考一下，就算积分服务挂了，订单服务也可以不用挂啊！为什么？</strong></p>
<ul>
<li>我们结合业务来看：支付订单的时候，只要把库存扣减了，然后通知仓库发货就OK了</li>
<li>如果积分服务挂了，大不了等他恢复之后，慢慢人肉手工恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！</li>
</ul>
<p><strong>现在问题分析完了，如何解决？</strong></p>
<p>这时就轮到Hystrix闪亮登场了。Hystrix是隔离、熔断以及降级的一个框架。啥意思呢？说白了，Hystrix会搞很多个小小的线程池，比如订单服务请求库存服务是一个线程池，请求仓储服务是一个线程池，请求积分服务是一个线程池。每个线程池里的线程就仅仅用于请求那个服务。</p>
<p><strong>打个比方：现在很不幸，积分服务挂了，会咋样？</strong></p>
<p>当然会导致订单服务里那个用来调用积分服务的线程都卡死不能工作了啊！但由于订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以这两个服务不会受到任何影响。</p>
<p>这个时候如果别人请求订单服务，订单服务还是可以正常调用库存服务扣减库存，调用仓储服务通知发货。只不过调用积分服务的时候，每次都会报错。<strong>但是如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！</strong>所以我们直接对积分服务熔断不就得了，比如在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟，<strong>这个过程，就是所谓的熔断！</strong></p>
<p><strong>那人家又说，兄弟，积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？</strong> 没问题，咱们就来个降级：每次调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！这样等积分服务恢复了，你可以根据这些记录手工加一下积分。<strong>这个过程，就是所谓的降级。</strong></p>
<p>为帮助大家更直观的理解，接下来用一张图，梳理一下Hystrix隔离、熔断和降级的全流程：</p>
<p><img src="166ec004edf94426" alt=""></p>
<h2 id="Spring-Cloud核心组件：Zuul"><a href="#Spring-Cloud核心组件：Zuul" class="headerlink" title="Spring Cloud核心组件：Zuul"></a>Spring Cloud核心组件：Zuul</h2><p>说完了Hystrix，接着给大家说说最后一个组件：Zuul，也就是微服务网关。<strong>这个组件是负责网络路由的。</strong> 不懂网络路由？行，那我给你说说，如果没有Zuul的日常工作会怎样？</p>
<p>假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。<strong>打个比方：</strong> 人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？部署在5台机器上？就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？你要这样玩儿，那真是友谊的小船，说翻就翻！</p>
<p>上面这种情况，压根儿是不现实的。所以一般微服务架构中都必然会设计一个网关在里面，像android、ios、pc前端、微信小程序、H5等等，不用去关心后端有几百个服务，就知道有一个网关，所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务。</p>
<p>而且有一个网关之后，还有很多好处，比如可以做<strong>统一的降级、限流、认证授权、安全，</strong>等等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后再来总结一下，上述几个Spring Cloud核心组件，在微服务架构中，分别扮演的角色：</p>
<ul>
<li><strong>Eureka：</strong> 各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而知道其他服务在哪里</li>
<li>Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台</li>
<li>Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求</li>
<li>Hystrix：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题</li>
<li>Zuul：如果前端、移动端要调用后端系统，统一从Zuul网关进入，由Zuul网关转发请求给对应的服务</li>
</ul>
<p>以上就是我们通过一个电商业务场景，阐述了Spring Cloud微服务架构几个核心组件的底层原理。</p>
<p><strong>文字总结还不够直观？没问题！</strong> 我们将Spring Cloud的5个核心组件通过一张图串联起来，再来直观的感受一下其底层的架构原理：</p>
<p><img src="166ec006b1536f43" alt=""></p>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么分布式一定要有redis?]]></title>
      <url>http://kxh.ink/2018/11/08/why-is-redis/</url>
      <content type="html"><![CDATA[<h2 id="为什么使用redis"><a href="#为什么使用redis" class="headerlink" title="为什么使用redis"></a>为什么使用redis</h2><p><strong>分析</strong>:博主觉得在项目中使用redis，主要是从两个角度去考虑:性能和并发。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。</p>
<a id="more"></a>
<p><strong>回答:如下所示，分为两点</strong></p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</p>
<p><img src="19c2ad17bb3685a1316adbae40504edf.jpg" alt=""></p>
<p>题外话：忽然想聊一下这个迅速响应的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:”在理想状态下，我们的页面跳转需要在瞬间解决，对于页内操作则需要在刹那间解决。另外，超过一弹指的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。”</p>
<p>那么瞬间、刹那、一弹指具体是多少时间呢？</p>
<p>根据《摩诃僧祗律》记载</p>
<p>一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。</p>
<p>那么，经过周密的计算，一瞬间为0.36 秒,一刹那有 0.018 秒.一弹指长达 7.2 秒。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</p>
<p><img src="a6670ab7b9d361ee8a05279ded8466f2.jpg" alt=""></p>
<h2 id="使用redis有什么缺点"><a href="#使用redis有什么缺点" class="headerlink" title="使用redis有什么缺点"></a>使用redis有什么缺点</h2><p><strong>分析:</strong> 大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。</p>
<p>回答:主要是四个问题</p>
<ul>
<li>缓存和数据库双写一致性问题</li>
<li>缓存雪崩问题</li>
<li>缓存击穿问题</li>
<li>缓存的并发竞争问题</li>
</ul>
<p>这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。</p>
<h2 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" class="headerlink" title="单线程的redis为什么这么快"></a>单线程的redis为什么这么快</h2><p><strong>分析:</strong> 这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。</p>
<p>回答:主要是以下三点</p>
<ul>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>采用了非阻塞I/O多路复用机制</li>
</ul>
<p><strong>题外话：</strong> 我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了一批快递员，然后小曲发现资金不够了，只够买一辆车送快递。</p>
<p><strong>经营方式一</strong><br>客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题</p>
<p>几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递<br>随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了<br>快递员之间的协调很花时间<br>综合上述缺点，小曲痛定思痛，提出了下面的经营方式</p>
<p><strong>经营方式二</strong></p>
<p>小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按送达地点标注好，然后依次放在一个地方。最后，那个快递员依次的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。</p>
<p><strong>对比</strong><br>上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:</p>
<p>每个快递员———-&gt;每个线程<br>每个快递————&gt;每个socket(I/O流)<br>快递的送达地点——&gt;socket的不同状态<br>客户送快递请求——&gt;来自客户端的请求<br>小曲的经营方式——&gt;服务端运行的代码<br>一辆车—————&gt;CPU的核数</p>
<p><strong>于是我们有如下结论</strong><br>1、经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。<br>2、经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。</p>
<p>下面类比到真实的redis线程模型，如图所示</p>
<p><img src="2a42d47ab2597eca67444004727de6ee.jpg" alt=""></p>
<p>参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</p>
<p>需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。</p>
<h2 id="redis的数据类型，以及每种数据类型的使用场景"><a href="#redis的数据类型，以及每种数据类型的使用场景" class="headerlink" title="redis的数据类型，以及每种数据类型的使用场景"></a>redis的数据类型，以及每种数据类型的使用场景</h2><p><strong>分析：</strong> 是不是觉得这个问题很基础，其实我也这么觉得。然而根据面试经验发现，至少百分八十的人答不上这个问题。建议，在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员，五种类型都会用到。</p>
<ul>
<li><strong>String</strong></li>
</ul>
<blockquote>
<p>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存</p>
</blockquote>
<ul>
<li><strong>Hash</strong> </li>
</ul>
<blockquote>
<p>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</p>
</blockquote>
<ul>
<li><strong>List</strong></li>
</ul>
<blockquote>
<p>使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。</p>
</blockquote>
<ul>
<li><strong>Set</strong></li>
</ul>
<blockquote>
<p>因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。</p>
</blockquote>
<p>另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p>
<ul>
<li><strong>sorted set</strong></li>
</ul>
<blockquote>
<p>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。sorted set可以用来做延时任务。最后一个应用就是可以做范围查找。</p>
</blockquote>
<h2 id="redis的过期策略以及内存淘汰机制"><a href="#redis的过期策略以及内存淘汰机制" class="headerlink" title="redis的过期策略以及内存淘汰机制"></a>redis的过期策略以及内存淘汰机制</h2><p><strong>分析:</strong> 这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p>
<p><strong>回答:</strong><br>redis采用的是定期删除+惰性删除策略。</p>
<p><strong>为什么不用定时删除策略?</strong><br>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.</p>
<p><strong>定期删除+惰性删除是如何工作的呢?</strong><br>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。</p>
<p>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>
<p><strong>采用定期删除+惰性删除就没其他问题了么?</strong><br>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。</p>
<p>在redis.conf中有一行配置</p>
<p><strong>maxmemory-policy volatile-lru</strong></p>
<p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。</li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐</li>
</ul>
<h2 id="redis和数据库双写一致性问题"><a href="#redis和数据库双写一致性问题" class="headerlink" title="redis和数据库双写一致性问题"></a>redis和数据库双写一致性问题</h2><p><strong>分析:</strong> 一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p>
<p><strong>回答:</strong> 首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p>
<h2 id="如何应对缓存穿透和缓存雪崩问题"><a href="#如何应对缓存穿透和缓存雪崩问题" class="headerlink" title="如何应对缓存穿透和缓存雪崩问题"></a>如何应对缓存穿透和缓存雪崩问题</h2><p><strong>分析:</strong> 这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。</p>
<p><strong>回答:</strong> 如下所示</p>
<blockquote>
<p>缓存穿透，即×××故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>
</blockquote>
<p><strong>解决方案:</strong></p>
<ul>
<li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</li>
<li>采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。</li>
<li>提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</li>
</ul>
<blockquote>
<p>缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p>
</blockquote>
<p><strong>解决方案:</strong></p>
<ul>
<li>给缓存的失效时间，加上一个随机值，避免集体失效。</li>
<li>使用互斥锁，但是该方案吞吐量明显下降了。</li>
<li>双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点<blockquote>
<p>从缓存A读数据库，有则直接返回<br>A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。<br>更新线程同时更新缓存A和缓存B。</p>
</blockquote>
</li>
</ul>
<h2 id="如何解决redis的并发竞争key问题"><a href="#如何解决redis的并发竞争key问题" class="headerlink" title="如何解决redis的并发竞争key问题"></a>如何解决redis的并发竞争key问题</h2><p><strong>分析:</strong> 这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。</p>
<p><strong>回答:</strong> 如下所示</p>
<ul>
<li><strong>如果对这个key操作，不要求顺序</strong></li>
</ul>
<blockquote>
<p>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。</p>
</blockquote>
<ul>
<li><strong>如果对这个key操作，要求顺序</strong></li>
</ul>
<blockquote>
<p>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.<br>期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</p>
<p>系统A key 1 {valueA 3:00}<br>系统B key 1 {valueB 3:05}<br>系统C key 1 {valueC 3:10}<br>那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p>
<p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对redis的常见问题做了一个总结。大部分是博主自己在工作中遇到，以及以前面试别人的时候，爱问的一些问题。另外，不推荐大家临时抱佛脚，真正碰到一些有经验的工程师，其实几下就能把你问懵.</p>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>http://kxh.ink/2018/11/02/mysql-transaction/README/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL 四种事务隔离级的说明]]></title>
      <url>http://kxh.ink/2018/11/02/mysql-transaction/</url>
      <content type="html"><![CDATA[<p>按照SQL:1992 事务隔离级别，InnoDB默认是可重复读的（REPEATABLE READ）。MySQL/InnoDB 提供SQL标准所描述的所有四个事务隔离级别。你可以在命令行用–transaction-isolation选项，或在选项文件里，为所有连接设置默认隔离级别。<br>例如，你可以在my.inf文件的[mysqld]节里类似如下设置该选项：</p>
<a id="more"></a>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction-isolation = &#123;READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure>
<p>用户可以用SET TRANSACTION语句改变单个会话或者所有新进连接的隔离级别。它的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">SESSION</span> | <span class="keyword">GLOBAL</span>] <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> &#123;<span class="keyword">READ</span> UNCOMMITTED | <span class="keyword">READ</span> COMMITTED | REPEATABLE <span class="keyword">READ</span> | <span class="keyword">SERIALIZABLE</span>&#125;</span><br></pre></td></tr></table></figure>
<p>注意：默认的行为（不带session和global）是为下一个（未开始）事务设置隔离级别。如果你使用GLOBAL关键字，语句在全局对从那点开始创建的所有新连接（除了不存在的连接）设置默认事务级别。你需要SUPER权限来做这个。使用SESSION 关键字为将来在当前连接上执行的事务设置默认事务级别。 任何客户端都能自由改变会话隔离级别（甚至在事务的中间），或者为下一个事务设置隔离级别。</p>
<p>你可以用下列语句查询全局和会话事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @@global.tx_isolation;</span><br><span class="line"><span class="keyword">SELECT</span> @@session.tx_isolation;</span><br><span class="line"><span class="keyword">SELECT</span> @@tx_isolation;</span><br></pre></td></tr></table></figure>
<h2 id="以上手册中的理论知识"><a href="#以上手册中的理论知识" class="headerlink" title="以上手册中的理论知识;"></a>以上手册中的理论知识;</h2><table>
<thead>
<tr>
<th style="text-align:left">隔离级别</th>
<th style="text-align:center">脏读（Dirty Read）</th>
<th style="text-align:center">不可重复读（NonRepeatable Read）</th>
<th style="text-align:right">幻读（Phantom Read） </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">未提交读（Read uncommitted）</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">可能</td>
<td style="text-align:right">可能 </td>
</tr>
<tr>
<td style="text-align:left">已提交读（Read committed）</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">可能</td>
<td style="text-align:right">可能</td>
</tr>
<tr>
<td style="text-align:left">可重复读（Repeatable read）</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
<td style="text-align:right">可能</td>
</tr>
<tr>
<td style="text-align:left">可串行化（Serializable ）</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
<td style="text-align:right">不可能</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>未提交读(Read Uncommitted)：</strong> 允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li>
<li><strong>已提交读(Read Committed)：</strong> 只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li>
<li><strong>可重复读(Repeated Read)：</strong> 可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</li>
<li><strong>可串行化(Serializable)：</strong> 完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li>
</ul>
<h2 id="用例子说明各个级别的情况："><a href="#用例子说明各个级别的情况：" class="headerlink" title="用例子说明各个级别的情况："></a>用例子说明各个级别的情况：</h2><ul>
<li><strong>脏读:</strong> 脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">mysql&gt; select @@global.tx_isolation;</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| @@global.tx_isolation |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| REPEATABLE-READ       |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> @@session.tx_isolation;</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| REPEATABLE-READ       |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into ttd values(1);</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ttd;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span> <span class="number">2</span>:</span><br><span class="line">mysql&gt; <span class="keyword">select</span> @@session.tx_isolation;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| REPEATABLE-READ        |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> @@global.tx_isolation;</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| @@global.tx_isolation |</span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">| REPEATABLE-READ   |        <span class="comment">--------该隔离级别下(除了 read uncommitted)</span></span><br><span class="line">+<span class="comment">-----------------------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> ttd;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.00</span> sec)              <span class="comment">--------不会出现脏读</span></span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommitted;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@session.tx_isolation;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| READ-UNCOMMITTED       |   <span class="comment">--------该隔离级别下</span></span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> ttd;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |                                       <span class="comment">--------REPEATABLE-READ级别出现脏读</span></span><br><span class="line"></span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p><strong>结论:</strong> session 2 在READ-UNCOMMITTED 下读取到session 1 中未提交事务修改的数据.</p>
<ul>
<li><strong>不可重复读:</strong> 是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">mysql&gt; select @@session.tx_isolation;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| READ-COMMITTED         |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ttd;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span> <span class="number">2</span> :</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> @@session.tx_isolation;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| REPEATABLE-READ        |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ttd;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> ttd <span class="keyword">values</span>(<span class="number">2</span>);  /也可以更新数据</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ttd;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">commit</span>;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">session 2 提交后,查看session 1 的结果;</span><br><span class="line"></span><br><span class="line">session 1:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ttd;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |                             <span class="comment">--------和第一次的结果不一样,READ-COMMITTED 级别出现了不重复读</span></span><br><span class="line">|    2 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>可重复读:</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">session 1:</span><br><span class="line">mysql&gt; select @@session.tx_isolation;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| REPEATABLE-READ        |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ttd;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |</span><br><span class="line">|    2 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span> <span class="number">2</span> :</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> @@session.tx_isolation;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| @@session.tx_isolation |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| REPEATABLE-READ        |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into ttd values(3);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">session 2 提交后,查看session 1 的结果;</span><br><span class="line"></span><br><span class="line">session 1:</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ttd;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| id   |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">|    1 |                                      <span class="comment">--------和第一次的结果一样,REPEATABLE-READ级别出现了重复读</span></span><br><span class="line">|    2 |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">(<span class="keyword">commit</span> <span class="keyword">session</span> <span class="number">1</span> 之后 再<span class="keyword">select</span> * <span class="keyword">from</span> ttd 可以看到<span class="keyword">session</span> <span class="number">2</span> 插入的数据<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>幻读:</strong>第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;CREATE TABLE `t_bitfly` (</span><br><span class="line">`id` bigint(20) NOT NULL default '0',</span><br><span class="line">`value` varchar(32) default NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB</span><br><span class="line"></span><br><span class="line">mysql&gt; select @@global.tx_isolation, @@tx_isolation;</span><br><span class="line">+<span class="comment">-----------------------+-----------------+</span></span><br><span class="line">| @@global.tx_isolation | @@tx_isolation  |</span><br><span class="line">+<span class="comment">-----------------------+-----------------+</span></span><br><span class="line">| REPEATABLE-READ       | REPEATABLE-READ |</span><br><span class="line">+<span class="comment">-----------------------+-----------------+</span></span><br><span class="line"></span><br><span class="line">实验一：</span><br><span class="line"></span><br><span class="line">t Session A                   Session B</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;          <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| empty <span class="keyword">set</span></span><br><span class="line">|                             <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_bitfly</span><br><span class="line">|                             <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'a'</span>);</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| empty <span class="keyword">set</span></span><br><span class="line">|                             <span class="keyword">COMMIT</span>;</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| empty <span class="keyword">set</span></span><br><span class="line">|</span><br><span class="line">| <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_bitfly <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'a'</span>);</span><br><span class="line">| ERROR 1062 (23000):</span><br><span class="line">| Duplicate entry '1' for key 1</span><br><span class="line">v (shit, 刚刚明明告诉我没有这条记录的)</span><br><span class="line"></span><br><span class="line">如此就出现了幻读，以为表里没有数据，其实数据已经存在了，傻乎乎的提交后，才发现数据冲突了。</span><br><span class="line"></span><br><span class="line">实验二：</span><br><span class="line"></span><br><span class="line">t Session A                  Session B</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;         <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| | id   | value |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| |    1 | a     |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">|                            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_bitfly</span><br><span class="line">|                            <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'b'</span>);</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| | id   | value |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| |    1 | a     |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">|                            <span class="keyword">COMMIT</span>;</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| | id   | value |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| |    1 | a     |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">|</span><br><span class="line">| <span class="keyword">UPDATE</span> t_bitfly <span class="keyword">SET</span> <span class="keyword">value</span>=<span class="string">'z'</span>;</span><br><span class="line">| Rows matched: 2  Changed: 2  Warnings: 0</span><br><span class="line">| (怎么多出来一行)</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| | id   | value |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| |    1 | z     |</span><br><span class="line">| |    2 | z     |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br></pre></td></tr></table></figure>
<p>本事务中第一次读取出一行，做了一次更新后，另一个事务里提交的数据就出现了。也可以看做是一种幻读。<br><strong>当隔离级别是可重复读，且禁用innodb_locks_unsafe_for_binlog的情况下，在搜索和扫描index的时候使用的next-key locks可以避免幻读。</strong></p>
<p>再看一个实验，要注意，表t_bitfly里的id为主键字段。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">实验三：</span><br><span class="line">t Session A                 Session B</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;        <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly</span><br><span class="line">| <span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;=<span class="number">1</span></span><br><span class="line">| <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| | id   | value |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| |    1 | a     |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">|                           <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_bitfly</span><br><span class="line">|                           <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'b'</span>);</span><br><span class="line">|                           Query OK, 1 row affected</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| | id   | value |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| |    1 | a     |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">|                           <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_bitfly</span><br><span class="line">|                           <span class="keyword">VALUES</span> (<span class="number">0</span>, <span class="string">'0'</span>);</span><br><span class="line">|                           (waiting for <span class="keyword">lock</span> ...then <span class="keyword">timeout</span>)</span><br><span class="line">|                           <span class="keyword">ERROR</span> <span class="number">1205</span> (HY000):</span><br><span class="line">|                           <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded;</span><br><span class="line">|                           try restarting transaction</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| | id   | value |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| |    1 | a     |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">|                           <span class="keyword">COMMIT</span>;</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line"></span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| | id   | value |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br><span class="line">| |    1 | a     |</span><br><span class="line">| +<span class="comment">------+-------+</span></span><br></pre></td></tr></table></figure>
<p>可以看到，用id&lt;=1加的锁，只锁住了id&lt;=1的范围，可以成功添加id为2的记录，添加id为0的记录时就会等待锁的释放。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">实验四：一致性读和提交读</span><br><span class="line">t Session A                      Session B</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;             <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">| | id | value |</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">| |  1 | a     |</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">|                                <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_bitfly</span><br><span class="line">|                                <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'b'</span>);</span><br><span class="line">|                                <span class="keyword">COMMIT</span>;</span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">| | id | value |</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">| |  1 | a     |</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">| | id | value |</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">| |  1 | a     |</span><br><span class="line">| |  2 | b     |</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">| | id | value |</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">| |  1 | a     |</span><br><span class="line">| |  2 | b     |</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">|</span><br><span class="line">| <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_bitfly;</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">| | id | value |</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br><span class="line">| |  1 | a     |</span><br><span class="line">| +<span class="comment">----+-------+</span></span><br></pre></td></tr></table></figure>
<p>如果使用普通的读，会得到一致性的结果，如果使用了<strong>加锁的读，就会读到“最新的”“提交”读的结果。</strong></p>
<p>本身，可重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。</p>
<p>可以这么讲，InnoDB提供了这样的机制，<strong>在默认的可重复读的隔离级别里，可以使用加锁读去查询最新的数据（提交读）。</strong><br>MySQL InnoDB的可重复读并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是next-key locks。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>四个级别逐渐增强，每个级别解决一个问题。事务级别越高,性能越差,大多数环境read committed 可以用.记住4个隔离级别的特点(上面的例子);</p>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>http://kxh.ink/2018/11/01/how-to-calculate-threadpool-size/README/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[如何合理地估算线程池大小？]]></title>
      <url>http://kxh.ink/2018/10/31/how-to-calculate-threadpool-size/</url>
      <content type="html"><![CDATA[<h2 id="如何合理地估算线程池大小？"><a href="#如何合理地估算线程池大小？" class="headerlink" title="如何合理地估算线程池大小？"></a>如何合理地估算线程池大小？</h2><p>这个问题虽然看起来很小，却并不那么容易回答。大家如果有更好的方法欢迎赐教，先来一个天真的估算方法：假设要求一个系统的TPS（Transaction Per Second或者Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s。那么问题转化为：</p>
<a id="more"></a>
<h2 id="如何设计线程池大小，使得可以在1s内处理完20个Transaction？"><a href="#如何设计线程池大小，使得可以在1s内处理完20个Transaction？" class="headerlink" title="如何设计线程池大小，使得可以在1s内处理完20个Transaction？"></a>如何设计线程池大小，使得可以在1s内处理完20个Transaction？</h2><p>计算过程很简单，每个线程的处理能力为0.25TPS（1个Transaction/4s），那么要达到20TPS，显然需要20/0.25=80个线程。</p>
<p>很显然这个估算方法很天真，因为它没有考虑到CPU数目。一般服务器的CPU核数为16或者32，如果有80个线程，那么肯定会带来太多不必要的线程上下文切换开销。</p>
<h2 id="再来第二种简单的但不知是否可行的方法（N为CPU总核数）："><a href="#再来第二种简单的但不知是否可行的方法（N为CPU总核数）：" class="headerlink" title="再来第二种简单的但不知是否可行的方法（N为CPU总核数）："></a>再来第二种简单的但不知是否可行的方法（N为CPU总核数）：</h2><ul>
<li>如果是CPU密集型应用，则线程池大小设置为N+1</li>
<li>如果是IO密集型应用，则线程池大小设置为2N+1</li>
</ul>
<p>如果一台服务器上只部署这一个应用并且只有这一个线程池，那么这种估算或许合理，具体还需自行测试验证。</p>
<p>接下来在这个文档：服务器性能IO优化 中发现一个估算公式：</p>
<blockquote>
<p><strong>最佳线程数目</strong> = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</p>
</blockquote>
<p>比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)*8=32。这个公式进一步转化为：</p>
<blockquote>
<p><strong>最佳线程数目</strong> = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</p>
</blockquote>
<p>可以得出一个结论：</p>
<blockquote>
<p>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</p>
</blockquote>
<p>上一种估算方法也和这个结论相合。</p>
<p>一个系统最快的部分是CPU，所以决定一个系统吞吐量上限的是CPU。增强CPU处理能力，可以提高系统吞吐量上限。但根据短板效应，真实的系统吞吐量并不能单纯根据CPU来计算。那要提高系统吞吐量，就需要从“系统短板”（比如网络延迟、IO）着手：</p>
<ul>
<li>尽量提高短板操作的并行化比率，比如多线程下载技术</li>
<li>增强短板能力，比如用NIO替代IO</li>
</ul>
<p>第一条可以联系到Amdahl定律，这条定律定义了串行系统并行化后的加速比计算公式：</p>
<blockquote>
<p>加速比=优化前系统耗时 / 优化后系统耗时</p>
</blockquote>
<p>加速比越大，表明系统并行化的优化效果越好。Addahl定律还给出了系统并行度、CPU数目和加速比的关系，加速比为Speedup，系统串行化比率（指串行执行代码所占比率）为F，CPU数目为N：</p>
<blockquote>
<p>Speedup &lt;= 1 / (F + (1-F)/N)</p>
</blockquote>
<p>当N足够大时，串行化比率F越小，加速比Speedup越大。</p>
<p>写到这里，我突然冒出一个问题。</p>
<blockquote>
<p>是否使用线程池就一定比使用单线程高效呢？</p>
</blockquote>
<p>答案是否定的，比如Redis就是单线程的，但它却非常高效，基本操作都能达到十万量级/s。从线程这个角度来看，部分原因在于：</p>
<ul>
<li>多线程带来线程上下文切换开销，单线程就没有这种开销</li>
<li>锁</li>
</ul>
<p>当然“Redis很快”更本质的原因在于：Redis基本都是内存操作，这种情况下单线程可以很高效地利用CPU。而多线程适用场景一般是：存在相当比例的IO和网络操作。</p>
<p>所以即使有上面的简单估算方法，也许看似合理，但实际上也未必合理，都需要结合系统真实情况（比如是IO密集型或者是CPU密集型或者是纯内存操作）和硬件环境（CPU、内存、硬盘读写速度、网络状况等）来不断尝试达到一个符合实际的合理估算值。</p>
<p>最后来一个“Dark Magic”估算方法（因为我暂时还没有搞懂它的原理），使用下面的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A class that calculates the optimal thread pool boundaries. It takes the</span></span><br><span class="line"><span class="comment"> * desired target utilization and the desired work queue memory consumption as</span></span><br><span class="line"><span class="comment"> * input and retuns thread count and work queue capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Niklas Schlimm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolSizeCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The sample queue size to calculate the size of a single &#123;<span class="doctag">@link</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">     * element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SAMPLE_QUEUE_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Accuracy of test run. It must finish within 20ms of the testTime</span></span><br><span class="line"><span class="comment">     * otherwise we retry the test. This could be configurable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> EPSYLON = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Control variable for the CPU time investigation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> expired;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Time (millis) of the test run in the CPU time calculation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> testtime = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calculates the boundaries of a thread pool for a given &#123;<span class="doctag">@link</span> Runnable&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetUtilization the desired utilization of the CPUs (0 &lt;= targetUtilization &lt;= 	 *            1) 	 * <span class="doctag">@param</span> targetQueueSizeBytes 	 *            the desired maximum work queue size of the thread pool (bytes)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">calculateBoundaries</span><span class="params">(BigDecimal targetUtilization, BigDecimal targetQueueSizeBytes)</span> </span>&#123;</span><br><span class="line">        calculateOptimalCapacity(targetQueueSizeBytes);</span><br><span class="line">        Runnable task = creatTask();</span><br><span class="line">        start(task);</span><br><span class="line">        start(task); <span class="comment">// warm up phase</span></span><br><span class="line">        <span class="keyword">long</span> cputime = getCurrentThreadCPUTime();</span><br><span class="line">        start(task); <span class="comment">// test intervall</span></span><br><span class="line">        cputime = getCurrentThreadCPUTime() - cputime;</span><br><span class="line">        <span class="keyword">long</span> waittime = (testtime * <span class="number">1000000</span>) - cputime;</span><br><span class="line">        calculateOptimalThreadCount(cputime, waittime, targetUtilization);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculateOptimalCapacity</span><span class="params">(BigDecimal targetQueueSizeBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mem = calculateMemoryUsage();</span><br><span class="line">        BigDecimal queueCapacity = targetQueueSizeBytes.divide(<span class="keyword">new</span> BigDecimal(mem),</span><br><span class="line">                RoundingMode.HALF_UP);</span><br><span class="line">        System.out.println(<span class="string">"Target queue memory usage (bytes): "</span></span><br><span class="line">                + targetQueueSizeBytes);</span><br><span class="line">        System.out.println(<span class="string">"createTask() produced "</span> + creatTask().getClass().getName() + <span class="string">" which took "</span> + mem + <span class="string">" bytes in a queue"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Formula: "</span> + targetQueueSizeBytes + <span class="string">" / "</span> + mem);</span><br><span class="line">        System.out.println(<span class="string">"* Recommended queue capacity (bytes): "</span> + queueCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Brian Goetz' optimal thread count formula, see 'Java Concurrency in</span></span><br><span class="line"><span class="comment">     * * Practice' (chapter 8.2) 	 *</span></span><br><span class="line"><span class="comment">     * * <span class="doctag">@param</span> cpu</span></span><br><span class="line"><span class="comment">     * *            cpu time consumed by considered task</span></span><br><span class="line"><span class="comment">     * * <span class="doctag">@param</span> wait</span></span><br><span class="line"><span class="comment">     * *            wait time of considered task</span></span><br><span class="line"><span class="comment">     * * <span class="doctag">@param</span> targetUtilization</span></span><br><span class="line"><span class="comment">     * *            target utilization of the system</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculateOptimalThreadCount</span><span class="params">(<span class="keyword">long</span> cpu, <span class="keyword">long</span> wait,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             BigDecimal targetUtilization)</span> </span>&#123;</span><br><span class="line">        BigDecimal waitTime = <span class="keyword">new</span> BigDecimal(wait);</span><br><span class="line">        BigDecimal computeTime = <span class="keyword">new</span> BigDecimal(cpu);</span><br><span class="line">        BigDecimal numberOfCPU = <span class="keyword">new</span> BigDecimal(Runtime.getRuntime()</span><br><span class="line">                .availableProcessors());</span><br><span class="line">        BigDecimal optimalthreadcount = numberOfCPU.multiply(targetUtilization)</span><br><span class="line">                .multiply(<span class="keyword">new</span> BigDecimal(<span class="number">1</span>).add(waitTime.divide(computeTime,</span><br><span class="line">                        RoundingMode.HALF_UP)));</span><br><span class="line">        System.out.println(<span class="string">"Number of CPU: "</span> + numberOfCPU);</span><br><span class="line">        System.out.println(<span class="string">"Target utilization: "</span> + targetUtilization);</span><br><span class="line">        System.out.println(<span class="string">"Elapsed time (nanos): "</span> + (testtime * <span class="number">1000000</span>));</span><br><span class="line">        System.out.println(<span class="string">"Compute time (nanos): "</span> + cpu);</span><br><span class="line">        System.out.println(<span class="string">"Wait time (nanos): "</span> + wait);</span><br><span class="line">        System.out.println(<span class="string">"Formula: "</span> + numberOfCPU + <span class="string">" * "</span></span><br><span class="line">                + targetUtilization + <span class="string">" * (1 + "</span> + waitTime + <span class="string">" / "</span></span><br><span class="line">                + computeTime + <span class="string">")"</span>);</span><br><span class="line">        System.out.println(<span class="string">"* Optimal thread count: "</span> + optimalthreadcount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * * Runs the &#123;<span class="doctag">@link</span> Runnable&#125; over a period defined in &#123;<span class="doctag">@link</span> #testtime&#125;.</span></span><br><span class="line"><span class="comment">     * * Based on Heinz Kabbutz' ideas</span></span><br><span class="line"><span class="comment">     * * (http://www.javaspecialists.eu/archive/Issue124.html).</span></span><br><span class="line"><span class="comment">     * *</span></span><br><span class="line"><span class="comment">     * * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment">     * *            the runnable under investigation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> runs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (++runs &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Test not accurate"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            expired = <span class="keyword">false</span>;</span><br><span class="line">            start = System.currentTimeMillis();</span><br><span class="line">            Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">            timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    expired = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, testtime);</span><br><span class="line">            <span class="keyword">while</span> (!expired) &#123;</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">            start = System.currentTimeMillis() - start;</span><br><span class="line">            timer.cancel();</span><br><span class="line">        &#125; <span class="keyword">while</span> (Math.abs(start - testtime) &gt; EPSYLON);</span><br><span class="line">        collectGarbage(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectGarbage</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calculates the memory usage of a single element in a work queue. Based on</span></span><br><span class="line"><span class="comment">     * Heinz Kabbutz' ideas</span></span><br><span class="line"><span class="comment">     * (http://www.javaspecialists.eu/archive/Issue029.html).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> memory usage of a single &#123;<span class="doctag">@link</span> Runnable&#125; element in the thread</span></span><br><span class="line"><span class="comment">     * pools work queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">calculateMemoryUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BlockingQueue queue = createWorkQueue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SAMPLE_QUEUE_SIZE; i++) &#123;</span><br><span class="line">            queue.add(creatTask());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> mem0;</span><br><span class="line">        <span class="keyword">long</span> mem1;</span><br><span class="line">        collectGarbage(<span class="number">15</span>);</span><br><span class="line">        mem0 = Runtime.getRuntime().totalMemory()</span><br><span class="line">                - Runtime.getRuntime().freeMemory();</span><br><span class="line">        queue = createWorkQueue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SAMPLE_QUEUE_SIZE; i++) &#123;</span><br><span class="line">            queue.add(creatTask());</span><br><span class="line">        &#125;</span><br><span class="line">        collectGarbage(<span class="number">15</span>);</span><br><span class="line">        mem1 = Runtime.getRuntime().totalMemory()</span><br><span class="line">                - Runtime.getRuntime().freeMemory();</span><br><span class="line">        <span class="keyword">return</span> (mem1 - mem0) / SAMPLE_QUEUE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create your runnable task here.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an instance of your runnable task under investigation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Runnable <span class="title">creatTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return an instance of the queue used in the thread pool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> queue instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> BlockingQueue <span class="title">createWorkQueue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calculate current cpu time. Various frameworks may be used here,</span></span><br><span class="line"><span class="comment">     * depending on the operating system in use. (e.g.</span></span><br><span class="line"><span class="comment">     * http://www.hyperic.com/products/sigar). The more accurate the CPU time</span></span><br><span class="line"><span class="comment">     * measurement, the more accurate the results for thread count boundaries.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> current cpu time of current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getCurrentThreadCPUTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后自己继承这个抽象类并实现它的三个抽象方法，比如下面是我写的一个示例（任务是请求网络数据），其中我指定期望CPU利用率为1.0（即100%），任务队列总大小不超过100,000字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePoolSizeCaculatorImpl</span> <span class="keyword">extends</span> <span class="title">PoolSizeCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Runnable <span class="title">creatTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncIOTask();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> BlockingQueue <span class="title">createWorkQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getCurrentThreadCPUTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PoolSizeCalculator poolSizeCalculator = <span class="keyword">new</span> SimplePoolSizeCaculatorImpl();</span><br><span class="line">        poolSizeCalculator.calculateBoundaries(<span class="keyword">new</span> BigDecimal(<span class="number">1.0</span>), <span class="keyword">new</span> BigDecimal(<span class="number">100000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的异步IO任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Will</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncIOTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpURLConnection connection = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String getURL = <span class="string">"http://baidu.com"</span>;</span><br><span class="line">            URL getUrl = <span class="keyword">new</span> URL(getURL);</span><br><span class="line"></span><br><span class="line">            connection = (HttpURLConnection) getUrl.openConnection();</span><br><span class="line">            connection.connect();</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                    connection.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// empty loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            connection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到的输出如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Target queue memory usage (bytes): 100000</span><br><span class="line">createTask() produced pool_size_calculate.AsyncIOTask which took 40 bytes in a queue</span><br><span class="line">Formula: 100000 / 40</span><br><span class="line">* Recommended queue capacity (bytes): 2500</span><br><span class="line">Number of CPU: 4</span><br><span class="line">Target utilization: 1</span><br><span class="line">Elapsed time (nanos): 3000000000</span><br><span class="line">Compute time (nanos): 47181000</span><br><span class="line">Wait time (nanos): 2952819000</span><br><span class="line">Formula: 4 * 1 * (1 + 2952819000 / 47181000)</span><br><span class="line">* Optimal thread count: 256</span><br></pre></td></tr></table></figure>
<p>推荐的任务队列大小为2500，线程数为256，有点出乎意料之外。我可以如下构造一个线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool =</span><br><span class="line"> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">256</span>, <span class="number">256</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">2500</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解HashMap]]></title>
      <url>http://kxh.ink/2018/09/19/HashMap-System-Learning/</url>
      <content type="html"><![CDATA[<p>首先介绍一下Hash表:</p>
<h1 id="哈希表定义"><a href="#哈希表定义" class="headerlink" title="哈希表定义"></a>哈希表定义</h1><p>Hash,一般翻译做”散列”,也有直译为”哈希”的,就把任意长的输入(又叫做预映射,pre-image),通过散列算法,变换成固定长度输出,该输出就是散列值.</p>
<p><strong>这种转换是一种压缩映射,</strong>也就是, 散列值的空间通常远小于输入的空间,不同的输入可能会散列成相同的输出,而不可能从散列值来唯一的确定输入值.<strong>简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数.</strong></p>
<a id="more"></a>
<p>Hash主要用于信息安全领域中加密算法,它把一些不同长度的信息转化成杂乱的128位的编码,这些编码值叫做Hash值.也可以说.Hash就是找到一种数据内容和数据地址之间的映射关系例如字符串hello的哈希算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> value = <span class="string">"hello"</span>; <span class="keyword">int</span> key = (((((((<span class="number">27</span> (<span class="keyword">int</span>)<span class="string">'h'</span>+<span class="number">27</span>) (<span class="keyword">int</span>)<span class="string">'e'</span>) + <span class="number">27</span>) 　 (<span class="keyword">int</span>)<span class="string">'l'</span>) + <span class="number">27</span>)  (<span class="keyword">int</span>)<span class="string">'l'</span> +<span class="number">27</span>)  <span class="number">27</span> ) + (<span class="keyword">int</span>)<span class="string">'o'</span> ;</span><br></pre></td></tr></table></figure>
<h2 id="接着说一下HashMap"><a href="#接着说一下HashMap" class="headerlink" title="接着说一下HashMap"></a>接着说一下HashMap</h2><p>我想大家对于HashMap并不陌生,程序员基本上使用HashMap.估计很多公司面试的时候都会聊起HashMap,既然HashMap这么重要,我们就一起谈谈这个HashMap.</p>
<ul>
<li>HashMap概述及实现原理</li>
<li>HashMap的数据结构</li>
<li>HashMap的几个关键属性</li>
<li>HashMap的存取实现</li>
<li>fail-fast策略</li>
<li>Hash冲突以及如何解决Hash冲突</li>
<li>HashMap和HashTable区别</li>
</ul>
<h1 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h1><blockquote>
<p>定义:HashMap实现了Map接口,继承自AbstractMap.其中Map接口定义了键映射到值得规则,而Abstract类已经实现了Map,这里标注Map 这样应该是更加清晰<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>数组特点:</p>
<blockquote>
<p>寻址容易,插入和删除困难.</p>
</blockquote>
<p>链表得特点:</p>
<blockquote>
<p>寻址困难,插入和删除容易.</p>
</blockquote>
<p><strong>实现原理</strong> 简单得说,HashMap得key做Hash算法,并将Hash值映射到内存地址,直接取得key对应的value.</p>
<p>HashMap的高性能需要保证以下几点:</p>
<ul>
<li>将key Hash的算法必须是高效的</li>
<li>Hash值映射到内存地址(数组索引)的算法是快速的</li>
<li>根据内存地址(数组索引)可以直接取得对应的值</li>
</ul>
<h2 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h2><p>HashMap的数据结构:在Java语言中,最基本的数据结构就两种,一种是数组,另一种是模拟指针(引用),所有的数据结构都可以使用这两种数据结构构造,HashMap也是可以这样的.HashMap其实就是链表散列,是数组和链表的结合体.图下:<br><img src="687474703a2f2f696d672e6d792e6373.png" alt=""></p>
<p>观察HashMap的结构图,我们了解到HashMap底层是一个数组,数组中每一项是一个链表.HashMap提供了三个构造函数:</p>
<ul>
<li>HashMap()是一个默认的构造器,初始容量16,负载因子为0.75.</li>
<li>HashMap(int initialCapacity)是一个指定初始容量为initialCapacity,负载因子为0.75的空的HashMap.</li>
<li>HashMap(int initialCapacity,float loadFactor)是一个指定初始容量为initialCapacity,负载因子为loadFactor的空的HashMap.</li>
</ul>
<p>我们查看一下HashMap的初始化源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY,DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        threshold = initialCapacity;</span><br><span class="line">        init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashMap的几个关键属性"><a href="#HashMap的几个关键属性" class="headerlink" title="HashMap的几个关键属性"></a>HashMap的几个关键属性</h2><ol>
<li>initialCapacity<ul>
<li>initialCapacity为HashMap的最大容量,也就是底层数组的长度.</li>
</ul>
</li>
<li>加载因子loadFactor<ul>
<li>loadFactor为加载因子,即散列表的实际元素数目(n)/散列表的容量(m).另外,laodFactor越大,存储长度越小,查询时间越长.loadFactor越小,存储长度越大,查询时间短.HashMap默认的是0.75负载因子衡量的是一个散列表的空间的使用程度,负载因子越大表示散列表的装填程度越高,反之愈小.对于使用链表法的散列表来说,查找一个元素的平均时间是O(1+a).</li>
</ul>
</li>
</ol>
<h2 id="HashMap的存取实现"><a href="#HashMap的存取实现" class="headerlink" title="HashMap的存取实现"></a>HashMap的存取实现</h2><ol>
<li><p>存储<br> 我们先看看HashMap的put()方法的源码:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果table为null,inflate 该table</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当key为null,调用putForNullKey方法,保存null与table第一个位    置中,这是HashMap允许为null的原因</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 根据key的hashcode进行计算hash值.</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 根据指定hash值在找到对应的table中的索引. </span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 若 i 索引处的 Entry 不为 null,通过循环不断遍历 e 元素的下    一个元素.</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 判断该条链上是否有hash值相同的(key相同)</span></span><br><span class="line">        <span class="comment">// 若存在相同,则直接覆盖value,返回旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key ||    key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果i索引处的Entry为null,表明此处还没有Entry.</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 将key、value添加到i索引处.</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 分析了上面put()方法源代码中可以看出:</p>
<ul>
<li>当我们向HashMap中put元素的时候,先根据key的HashCode的值计算    Hash值,根据Hash值得到这个元素在数组中的位置(即下标).</li>
<li>如果数组该位置上已经存放有其他元素了,那么在这个位置上的元素将 以链表的形式存放,新加入的放在链头,最先加入的放在链尾.</li>
<li><p>如果数组该位置上没有元素,就直接将该元素放到此数组中的该位置上 .<br>addEntry(hash, key, value, i)方法根据计算出的hash值,将key-value 对放在数组table的i索引处.addEntry 是 HashMap 提供的一个包访问权限    的方法,代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 如果 Map 中的 key-value 对的数量超过了极限</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span>!=table[bucketIndex]))&#123;</span><br><span class="line">        <span class="comment">// 把 table 对象的长度扩充到原来的2倍. </span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据bucketIndex 获取对应的 Entry  </span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 将新创建的 Entry 放入 bucketIndex 索引处,并让新的 Entry  指向原来的 Entry </span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Hash方法,该方法为一个纯粹的数学计算,就是计算h的Hash值.我们知道对于HashMap的table而言,数据分布需要均匀(最好每项都只有一个元素,只有就可以直接找到了),不能太紧也不能太松,太紧导致查询速度慢,太松则浪费空间.计算Hash值后,怎么才能保证table元素分布均匀呢?我们会想到取模,但是由于取模的消耗大,HashMap是这样处理的:<br>调用indexFor方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap的底层数组总是2的n次方,在构造函数中存在:capacity &lt;&lt;= 1;这样做总是能够保证HashMap的底层数组的长度为2的n次方.当length为2的n次方时候,h&amp;(lenth-1)就相当于对length取模,而且速度比直接取模快的多,这是HashMap在速度上的一种优化.至于为什么是2的n次方下面解释.我们回到indexFor方法,该方法仅有一条语句:h&amp;(length-1),这句话除了上面的取模运算外还有一个非常重要的责任:均匀分布table数据和充分利用空间.</p>
<p>接下来我们以Key值为“apple”的例子来演示这个过程:</p>
<blockquote>
<p>计算“apple”的hashcode,结果为十进制的3029737,二进制的101110001110101110 1001<br>HashMap默认初始长度是16,计算HashMap.Length-1的结果为十进制的15,二进制的1111<br>把以上两个结果做 与运算,101110001110101110 1001 &amp; 1111 = 1001,十进制是9,所以 index=9</p>
</blockquote>
<p>可以看出来,hash算法得到的index值完全取决与Key的HashCode的最后几位.这样做不但效果上等同于取模运算,而且大大提高了效率.</p>
<p>那么回到最初的问题,初始长度为什么是16或者2的次幂?如果不是会怎么样?</p>
<p>我们假设HaspMap的初始长度为10,重复前面的运算步骤:<br><img src="7347393-a9962c5fb92eb958.png" alt=""></p>
<p>单独看这个结果,表面上并没有问题.我们再来尝试一个新的HashCode 101110001110101110 1011:<br><img src="7347393-5a4b6c0a2fc4eef0.png" alt=""></p>
<p>然后我们再换一个HashCode 101110001110101110 1111 试试:<br><img src="7347393-e37f9d5a943823b1.png" alt=""></p>
<p>这样我们可以看到,虽然HashCode的倒数第二第三位从0变成了1,但是运算的结果都是1001.也就是说,当HashMap长度为10的时候,有些index结果的出现几率会更大,而有些index结果永远不会出现（比如0111）  </p>
<p>所以这样显然不符合Hash算法均匀分布的原则.</p>
<p>而长度是16或者其他2的次幂,Length - 1的值的所有二进制位全为1（如15的二进制是1111,31的二进制为11111）,这种情况下,index的结果就等同于HashCode后几位的值.只要输入的HashCode本身分布均匀,Hash算法的结果就是均匀的.这也是HashMap设计的玄妙之处.</p>
</li>
</ul>
</li>
<li><p>获取</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 如果key = null时,返回null对应的value值.</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> getForNullKey(); </span><br><span class="line">    <span class="comment">// 根据key的hashcode值做hash获取对应的值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode()); </span><br><span class="line">    <span class="comment">// 根据指定hash值在找到对应的table中的索引,并根据索引获取该处  的Entry,通过循环不断遍历 e 元素的下一个元素.</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];  </span><br><span class="line">        e != <span class="keyword">null</span>;  </span><br><span class="line">        e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="comment">// 判断e元素的hash与hash是否相等,如果相等并且e元素与key    相等则返回e的原则的value</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key ||    key.equals(k)))  </span><br><span class="line">            <span class="keyword">return</span> e.value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果指定hash值在找到对应的table中的索引,并根据索引获取该处  的Entry的为null,则返回null.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 从get()的源代码中可以看出:从HashMap中get元素时,首先计算key的hashCode,通过IndexFor(hash,table.length)找到数组中对应位置的某一元素,然后通过key的equals方法在对应位置的链表中找到需要的元素.</p>
<blockquote>
<p>总结：HashMap 在底层将 key-value 当成一个整体进行处理,这个整体就是 Entry 对象.HashMap 底层采用一个 Entry[] 数组来保存所有的 key和value 键值对,当需要存储一个 Entry 对象时,会根据hash算法来决定其在数组中的存储位置,然后根据equals方法决定其在该数组位置上的链表中的存储位置；同样的当我们需要取出一个Entry时,也会根据hash算法找到其在数组中的存储位置,再根据equals方法从该位置上的链表中取出该Entry.</p>
</blockquote>
</li>
</ol>
<h2 id="fail-fast策略"><a href="#fail-fast策略" class="headerlink" title="fail-fast策略"></a>fail-fast策略</h2><blockquote>
<p>fail-fast策略：我们知道HashMap不是线程安全的,如果我们在使用迭代器过程中其他线程更改了该map,就会抛出ConcurrentModificationException,这就是所谓fail-fast策略.</p>
</blockquote>
<p>那么这个fail-fast策略是如何实现的呢？ 这个策略主要是通过modCount的这个值实现的,modCount顾名思义就是HashMap的修改次数.每次在HashMap的内容被修改都会增加这个值,那么在HashMap的迭代器被初始化的都会将这个值赋值给expectedModCount.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">        Entry[] t = table;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在HashMap的迭代器执行的过程中,代码会判断modCount和expectedModCount的值,如果不相等则表示HashMap的其他线程修改.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    Entry&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry[] t = table;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    current = e;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hash冲突以及如何解决hash冲突"><a href="#Hash冲突以及如何解决hash冲突" class="headerlink" title="Hash冲突以及如何解决hash冲突"></a>Hash冲突以及如何解决hash冲突</h2><p><strong>疑问：如果两个key通过hash % Entry[].length得到的index相同,会不会有覆盖的危险？</strong></p>
<p>这里 HashMap里面用到链式数据结构的一个概念.上面我们提到过 Entry 类里面有一个 next属性,作用是指向下一个 Entry.打个比方, 第一个键值对A进来,通过计算其 key的 hash得到的 index=0, 记做: <em>Entry[0] = A.</em>一会后又进来一个键值对B,通过计算其 index也等于0,现在怎么办？ HashMap会这样做 :<em>B.next = A,Entry[0] = B,</em>如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起.所以疑问不用担心.</p>
<p>当然HashMap里面也包含一些优化方面的实现,这里也啰嗦一下. 比如：Entry[]的长度一定后,随着map里面数据的越来越长,这样同一个index的链就会很长,会不会影响性能？HashMap里面设置一个因素（也称为因子）,随着map的size越来越大,Entry[]会以一定的规则加长长度.</p>
<h2 id="hash冲突解决办法"><a href="#hash冲突解决办法" class="headerlink" title="hash冲突解决办法"></a>hash冲突解决办法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);  </span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());  </span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);  </span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="comment">//判断当前确定的索引位置是否存在相同hashcode和相同key的元素,如果存在相同的hash值和相同的key的元素,那么新值覆盖原来的旧值,并返回旧值.  </span></span><br><span class="line">        <span class="comment">//如果存在相同的hash值,那么他们确定的索引位置就相同,这时判断他们的key是否相同,如果不相同,这时就是产生了我们常说的hash冲突.  </span></span><br><span class="line">        <span class="comment">//Hash冲突后,那么HashMap的单个bucket里存储的不是一个 Entry,而是一个 Entry 链.  </span></span><br><span class="line">        <span class="comment">//系统只能必须按顺序遍历每个Entry,直到找到想搜索的 Entry 为止——如果恰好要搜索的Entry位于该Entry链的最末端（该 Entry 是最早放入该 bucket 中） </span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        modCount++;  </span><br><span class="line">        addEntry(hash, key, value, i);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap里面的bucket出现了单链表的形式,散列表要解决的一个问题就是散列值的冲突问题,通常是两种方法：链表法和开放地址法.链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；开放地址法是通过一个探测算法,当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位.java.util.HashMap采用的链表法的方式,链表是单向链表.形成单链表的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 如果 Map 中的 key-value 对的数量超过了极限</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span>!=table[bucketIndex]))&#123;</span><br><span class="line">        <span class="comment">// 把 table 对象的长度扩充到原来的2倍. </span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据bucketIndex 获取对应的 Entry  </span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    <span class="comment">// 将新创建的 Entry 放入 bucketIndex 索引处,并让新的 Entry 指向原来的 Entry </span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法的代码大家可以看出,系统总是将新添加的 Entry 对象放入 table 数组的 bucketIndex 索引处——如果 bucketIndex 索引处已经有了一个 Entry 对象,那新添加的 Entry 对象指向原有的 Entry 对象（产生一个 Entry 链）,如果 bucketIndex 索引处没有 Entry 对象,也就是上面程序代码的 e 变量是 null,也就是新放入的 Entry 对象指向 null,也就是没有产生 Entry 链. HashMap里面没有出现hash冲突时,没有形成单链表时,HashMap查找元素很快,get()方法能够直接定位到元素,但是出现单链表后,单个bucket 里存储的不是一个 Entry,而是一个 Entry 链,系统只能必须按顺序遍历每个 Entry,直到找到想搜索的 Entry 为止——如果恰好要搜索的 Entry 位于该 Entry 链的最末端（该 Entry 是最早放入该 bucket 中）,那系统必须循环到最后才能找到该元素.</p>
<h2 id="HashMap和HashTable区别"><a href="#HashMap和HashTable区别" class="headerlink" title="HashMap和HashTable区别"></a>HashMap和HashTable区别</h2><blockquote>
<p>HashMap和HashTable采用的是相同的存储机制,因此两者的实现基本一致.</p>
</blockquote>
<p><strong>不同的是:</strong></p>
<blockquote>
<p>HashMap可以key和value均可以为null,而HashTable则不可以.HashTable不允许null的值,HashTable的key为null的时候,HashTable调用put方法时,直接抛出NullPointerException.其它细微的差别还有,比如初始化Entry数组的大小等等.<br>HashTable是线程安全的,内部的方法基本都是synchronized.hashmap则不是线程安全的.<br>HashTable中的hash数组默认是11,增加方式old*2+1.hashmap中hash数组的默认大小是16,而且一定是2的指数<br>HashTable有一个contains(Object value),功能和containsValue(Object value)功能一样<br>HashTable使用Enumeration,HashMap使用Iterator</p>
</blockquote>
<p><strong>以上只是表面的不同,它们的实现也有很大的不同.</strong></p>
<blockquote>
<p>HashTable中hash数组默认大小是11,增加的方式是 old*2+1.HashMap中hash数组的默认大小是16,而且一定是2的指数.<br>哈希值的使用不同,HashTable直接使用对象的hashCode,代码是这样的:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">而HashMap重新计算hash值,而且用与代替求模：</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> hash = hash(k);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">int</span> h = x.hashCode();</span><br><span class="line"></span><br><span class="line">　　h += ~(h &lt;&lt; <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">　　h ^= (h &gt;&gt;&gt; <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">　　h += (h &lt;&lt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">　　h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> h;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[显示锁（Lock）及Condition的学习与使用]]></title>
      <url>http://kxh.ink/2018/06/24/Lock-Condition/</url>
      <content type="html"><![CDATA[<p>synchronized是不错，但它并不完美。它有一些功能性的限制，比如:</p>
<ul>
<li>它无法中断一个正在等候获得锁的线程，也无法通过投票得到锁。多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。</li>
<li>synchronized上是非公平的,新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待。</li>
</ul>
<p>而Lock的一些实现类则很好的解决了这些问题。</p>
<a id="more"></a>
<h2 id="可重入锁-ReentrantLock"><a href="#可重入锁-ReentrantLock" class="headerlink" title="可重入锁 ReentrantLock"></a>可重入锁 ReentrantLock</h2><p>java.util.concurrent.lock中的Lock框架是锁定的一个抽象，它允许把锁定的实现所为Java类，而不是作为语言的特性来实现。这就为Lock的多种实现留下了空间，各种实现可能不同的调度算法、性能特性或者锁定语义。</p>
<p>ReentrantLock类实现了Lock，它拥有与syschronized相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。此外，它还提供了在激烈争用情况下更佳的性能。(换句句话，当许多线程都想访问共享资源时，JVM可以花更少的时候来调度线程，把更多时间用在执行线程上。)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockStudy</span> </span>&#123;     </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">// 锁对象   </span></span><br><span class="line">             </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">                        </span><br><span class="line">        lock.lock();      <span class="comment">// 得到锁       </span></span><br><span class="line">        <span class="keyword">try</span> &#123;                   </span><br><span class="line">            <span class="comment">//doSomething            </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;                  </span><br><span class="line">            lock.unlock();<span class="comment">// 释放锁                </span></span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，用syschronized修饰的方法或者语句块在代码执行完后锁自动释放，而用Lock需要我们手动释放锁，所以为了保证锁的最终被释放(发生异常情况)，需要互斥区放在try内，释放锁放在finally内。</p>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>ReentrantLock里有个函数newCondition(),该函数得到一个锁上的“条件”，用于实现线程间的通信，条件变量很大一个程度上是为了解决Object.wait/notify/notifAll难以使用的问题。</p>
<p>Condition拥有await(),signalAll(),await对应Object.wait，signal对应于Object.notify，signalALL对应Object.notifyAll。特别说明的是Condition的接口改变名称就是为了避免与Object中的wait/notify/notifyAll的语义和使用上混淆，因为Condition同样有wait/notify/notifyAll方法()因为任何类都拥有这些方法。</p>
<p>每一个Lock可以有任意数据的Condition对象，Condition是与Lock绑定的，所以就有Lock的公平性的特性：如果是公平锁，线程为了按照FIFO(先进先出原则)的顺序从Condition.await中释放，如果是非公平锁，那么后续的锁竞争就不保证FIFO顺序了。下面是一个用Lock和Condition实现的一个生产者消费者的模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head, tail, count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        items = T[] <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(count == getCapacity()) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            items[tail] = t;</span><br><span class="line">            <span class="keyword">if</span>(++tail==getCapacity())&#123;</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            T ret = items[head];</span><br><span class="line">            items[head] = <span class="keyword">null</span>;<span class="comment">//GC  </span></span><br><span class="line">            <span class="keyword">if</span> (++head == getCapacity()) &#123;</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signalAll();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个是多个Condition的强大之处，假设缓存队列中已经满了，那么阻塞的肯定是写线程，唤醒的肯定是读线程，相反，阻塞的肯定是读线程，唤醒的肯定是写线程，那么假设只有一个Condition会有什么效果，缓存队列已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒又被阻塞了。这时又去唤醒，这样就很浪费时间。</p>
<h2 id="ReentrantLock与synchronized的对比"><a href="#ReentrantLock与synchronized的对比" class="headerlink" title="ReentrantLock与synchronized的对比"></a>ReentrantLock与synchronized的对比</h2><p>ReentrantLock同样是一个可重入锁，但与目前的 synchronized 实现相比，争用下的 ReentrantLock 实现更具可伸缩性。除了synchronized的功能,多了三个高级功能.</p>
<ol>
<li><strong>等待可中断</strong><br> 在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待.<blockquote>
<p>tryLock(long timeout, TimeUnit unit)；</p>
</blockquote>
</li>
<li><strong>公平锁</strong><br> 按照申请锁的顺序来一次获得锁称为公平锁.synchronized的是非公平锁,ReentrantLock可以通过构造函数实现公平锁.<blockquote>
<p>new RenentrantLock(boolean fair)；</p>
</blockquote>
</li>
<li><strong>绑定多个Condition</strong><br> 通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能。通过await(),signal()等方法实现。</li>
</ol>
<h2 id="Lock的其他实现类"><a href="#Lock的其他实现类" class="headerlink" title="Lock的其他实现类"></a>Lock的其他实现类</h2><p>如ReadWriteLock。ReentrantReadWriteLock实现了ReadWriteLock接口，构造器提供了公平锁和非公平锁两种创建方式。读-写锁定允许对共享数据进行更高级别的并发访问。虽然一次只有一个线程（writer 线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程）。读写锁适用于读多写少的情况，可以实现更好的并发性。</p>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Callable和Future、FutureTask的使用]]></title>
      <url>http://kxh.ink/2018/06/21/Callable-Future-FutureTask/</url>
      <content type="html"><![CDATA[<p>在Java中，开启一个线程的唯一方式是，通过Thread的start方法，并且在线程中执行的Runnable的run方法。无论是线程池还是接下来要介绍的Callable，Future还是线程池，最核心最根本的还是调用的Thread.start()-&gt;Runnable.run(),其他的类的出现可以认为是更方便的使用Thread和Runnable，以此为核心更容易理解Java的并发框架。</p>
<a id="more"></a>
<p>虽然Thread和Runnable类使得多线程编程简单直接，但是有一个缺陷就是：在执行完任务之后无法获得执行结果。如果需要获得执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。因此从JDK1.5开始，有了一系列的类的出现来解决这些问题，如Callable和Future，FutureTask以及线程池《<a href="/2018/05/04/ThreadPoolPrinciple/">从使用到原理学习Java线程池</a>》。</p>
<p>而自从Java 1.5开始，就是提供Callable和Future以及FutureTask，通过它们可以在任务执行完毕之后得到任务执行结果。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><strong>Thread和Runnable</strong></p>
<p>首先看Thread和Runnable的实现多线程任务的原理。<br>以下是简化后的代码，为了方便理解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Runnable target;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">		target = Runnable;</span><br><span class="line">		 </span><br><span class="line">		<span class="comment">//省略其他初始化线程的任务</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		 nativeCreate(<span class="keyword">this</span>, stackSize, daemon);<span class="comment">//native方法开启多线程，并调用run方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">	        target.run();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出target是一个Runnable对象，通过一个典型的装饰者模式来扩展Runnable，如果不传入，默认为null，需要自己实现run方法在新线程里任务，否则线程不会做任何事情就结束。所以无论如何怎么变化，最终都是Thread的start方法开启新的线程，run方法在这个新开启的线程执行任务，当然run方法也是可以单独调用，但是所在的线程是调用者的线程。</p>
<blockquote>
<p>装饰者模式的典型特点：装饰后的类和被装饰的类，类型不变(继承Runnable)，提供新的行为，方法(start()等)。</p>
</blockquote>
<p><strong>Callable和Future，FutureTask</strong></p>
<p>先通过URML图来看它们和Thread，Runnable之间的关系：<br><img src="006tKfTcjw1f762nmu5r7j30my0bydhp.jpg" alt="Thread，Runnable之间的关系"> </p>
<p><em>Callable</em>与Runnable的功能大致相似，Callable中有一个call()函数，<strong>但是call()函数有返回值</strong>，而Runnable的run()函数不能将结果返回给客户程序。</p>
<p><em>Future</em>就是对Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作。其中的get()方法就是用来得到Callable的call()结果的。</p>
<p><em>FutureTask</em>是Future的具体实现类，实现了get()等方法来对控制Callable的行为，又因为Thread只能执行Runnable，所以FutureTask实现了Runnable接口。</p>
<p>因为FutureTask需要在Thread中执行，所以需要在run()方法中完成具体的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简化后的代码，为了方便理解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Callable&lt;V&gt; c = callable;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">        V result;</span><br><span class="line">        result = c.call();</span><br><span class="line">        set(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过get方法来获取结果，get()是哥阻塞方法，直到结果返回，或者中断发生。还可以通过get(long timeout, TimeUnit unit)方法控制等待结果的最大时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);<span class="comment">//阻塞等待</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出FutureTask的run方法实际的任务是在Callable的call中完成，FutureTask的实现方式采用了适配器模式来完成。</p>
<p>如果构造函数传入的是Runnable，则通过Executors的静态函数callable(Runnable task,…)将Runnable转换为Callable类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Callable <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter(task, result); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>适配模式的典型特点：包装另一个对象(包装了Callable)，提供不同的接口(Runnable接口)</p>
</blockquote>
<p><em>Callable</em>和<em>Future</em>，<em>FutureTask</em>经常容易让人记忆混乱，理解后就知道了其实Future和FutureTask就是用来将Callable包装成一个Runnable,这样才能够在Thread中执行，同时提供将结果返回的功能，三个类总是同时出现，整体理解为是一个可以得到返回结果的Runnable。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>那么怎么使用这些类呢？由于FutureTask实现了Runnable，因此它既可以通过Thread包装来直接执行，也可以提交给ExecutorService来执行，在Thread中，就像使用Runnable一样。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;                </span><br><span class="line">        FutureTest futureTest = <span class="keyword">new</span> FutureTest();            </span><br><span class="line">        futureTest.useExecutor();            </span><br><span class="line">        futureTest.useThread();  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">useExecutor</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">      </span><br><span class="line">        SumTask sumTask = <span class="keyword">new</span> SumTask(<span class="number">1000</span>);                </span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();    </span><br><span class="line">                </span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(sumTask);    </span><br><span class="line">                </span><br><span class="line">        executor.submit(futureTask);        </span><br><span class="line">        executor.shutdown();  </span><br><span class="line">             </span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"::useExecutor运行结果"</span> + futureTask.get());        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            </span><br><span class="line">            e.printStackTrace();      </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;            </span><br><span class="line">            e.printStackTrace();       </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">useThread</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        SumTask sumTask = <span class="keyword">new</span> SumTask(<span class="number">500</span>);          </span><br><span class="line">            </span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(sumTask) &#123;    </span><br><span class="line">            <span class="meta">@Override</span>    </span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">                <span class="keyword">super</span>.done();        </span><br><span class="line">                <span class="keyword">try</span> &#123;            </span><br><span class="line">                <span class="comment">// 这是在后台线程                   </span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"::useThread运行结果"</span> + get());        </span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            </span><br><span class="line">                    e.printStackTrace();        </span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;            </span><br><span class="line">                    e.printStackTrace();        </span><br><span class="line">                &#125;    </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;;          </span><br><span class="line">          </span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);       </span><br><span class="line">        thread.start();   </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">        	  <span class="comment">//这是在主线程，会阻塞           </span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"::useThread运行结果"</span> + futureTask.get().getName());       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;            </span><br><span class="line">            e.printStackTrace();       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;            </span><br><span class="line">            e.printStackTrace();       </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;        </span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;        </span><br><span class="line">      <span class="keyword">int</span> number;   </span><br><span class="line">           </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;            </span><br><span class="line">          <span class="keyword">this</span>.number = num;      </span><br><span class="line">      &#125;       </span><br><span class="line">       </span><br><span class="line">      <span class="meta">@Override</span>       </span><br><span class="line">      <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  </span><br><span class="line">          System.out.println(Thread.currentThread().getName());            </span><br><span class="line">          Thread.sleep(<span class="number">5000</span>);  </span><br><span class="line">                    </span><br><span class="line">          <span class="keyword">int</span> sum = <span class="number">0</span>;            </span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;                </span><br><span class="line">              sum += i;            </span><br><span class="line">          &#125;           </span><br><span class="line">          <span class="keyword">return</span> sum;        </span><br><span class="line">      &#125;    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<blockquote>
<p>pool-1-thread-1<br>main::useExecutor运行结果499500<br>Thread-0<br>main::useThread运行结果124750<br>Thread-0::useThread运行结果124750</p>
</blockquote>
<p>FutureTask.get()是阻塞的，useExecutor()和useThread()也会阻塞。这里只是说明FutureTask.get()所在的线程是调用者所在的线程，在Android中使用的话，一般是在FutureTask的done方法中get，这时get就是在后台线程调用了，然后通过Handler通知到UI或其他线程。</p>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从使用到原理学习Java线程池]]></title>
      <url>http://kxh.ink/2018/05/04/ThreadPoolPrinciple/</url>
      <content type="html"><![CDATA[<h2 id="线程池技术背景"><a href="#线程池技术背景" class="headerlink" title="线程池技术背景"></a>线程池技术背景</h2><p>在面向对象编程中,创建和销毁对象都是很费时间的,因为创建一个对象要获取内存资源或者其他更多资源.在Java中更是如此,虚拟机将试图跟踪每一个对象,以便能够在对象销毁后进行垃圾回收.<br><a id="more"></a><br>所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数,特别是一些很耗资源的对象创建和销毁.如何利用已有对象来服务就是一个需要解决的关键问题,其实这就是一些“池化资源”技术产生的原因.</p>
<p>例如Android中常见到的很多通用组件一般都离不开“池”的概念,如各种图片加载库,网络请求库,即使Android的消息传递机制的Message当使用Message.obtain()就是使用Message池中的对象,因为此这个概念很重要.本文将介绍的线程池技术同样符合这一思想.</p>
<h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><ol>
<li>重用线程池中的线程,减少因对象创建、销毁所带来的性能开销；</li>
<li>能有效的控制线程的最大并发数,提高系统资源利用率,同时避免过多的资源竞争,避免堵塞；</li>
<li>能够线程进行简单的管理,使线程的使用简单、高效；</li>
</ol>
<p>线程池框架Executor<br>Java中的线程池是通过Executor框架实现的,Executor框架包括类：Executor、Executors、ExecutorService、ThreadPoolExecutor、Callable和Future、FutureTask的使用等.</p>
<p><img src="20180319153538.jpg" alt="">  </p>
<p><strong>Executor：</strong>所有线程池的接口,只有一个方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>ExecutorService：</strong>增加Executor的行为,是Executor实现类最直接接口.<br><strong>Executors：</strong>提供了一系列工厂方法用于创建线程池,返回的线程池都实现了ExecutorService接口.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize,maximumPoolSize,keepAliveTime,workQueue,Executors.defaultThreadFactory(),defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>corePoolSize：</em>线程池的核心线程数,线程池中运行的线程数也永远不会超过corePoolSize个,默认情况下可以一直存活.可以通过设置allowCoreThreadTimeOut为true,此时核心线程数就是0,此时keepAliveTime控制所有线程的超时时间；<br><em>maximumPoolSize：</em>线程池运行的最大线程数；<br><em>keepAliveTime：</em>指的是空闲线程结束的超时时间；<br><em>unit：</em>是一个枚举,表示keepAliveTime的单位；<br><em>workQueue：</em>表示存放任务的BlockingQueue<runnable>队列.</runnable></p>
<blockquote>
<p>BlockingQueue：阻塞队列是java.util.concurrent下的主要控制线程同步的工具类,如果BlockingQueue是空的,从BlockingQueue取东西的操作将会被阻断进入等待状态,直到BlockingQueue进了东西才会被唤醒,同样,如果Blocking是满的,任何试图往里存东西的操作也会被阻断进入等待状态,直到BlockingQueue里有空间会被唤醒继续操作.<br>阻塞队列常用于生产者和消费者的场景,生产者就是往队列里添加元素的线程,消费者就是从队列里拿元素的线程.具体的实现类有LinkedBlockingQueue,ArrayBlockingQueued等.一般其内部的都是Lock和Condition来实现阻塞和唤醒.</p>
</blockquote>
<p>线程池的工作过程如下：<br>线程池刚创建时,里面没有一线程.任务队列是作为参数传进来的.不过,就算队列里面有任务,线程池也不会马上执行它们.<br>当调用execute()方法添加一个任务时,线程池会做如下判断：</p>
<blockquote>
<p>如果正在运行的线程数量小于corePoolSize,那么马上创建线程运行这个任务；<br>如果正在运行的线程数大于或等于corePoolSize,那么将这个任务放入队列；<br>如果这个时候队列满了,而且正在运行的线程数量小于maximumPoolSize,那么还是要创建非核心线程运行这个任务；<br>如果队列满了,而且正在运行的线程数量大于或等于maximumPoolSize,那么线程池抛出异常RejectExecutionException.<br>当一个线程完成任务时,它会从队列中取下一个任务和来执行.<br>当一个线程无事可做,超过一定的时间（keepAliveTime）时,线程池会判断,如果当前运行的线程数大于corePoolSize,那么这个线程就停掉.所以线程池的所有任务完成后,它最终会收缩到corePoolSize的大小.</p>
</blockquote>
<h2 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h2><p>生成线程池采用工具类Executors的静态方法,以下是几种常见的线程池.<br><em>SingleThreadExecutor：</em>单个后台线程（其缓冲队列是无界的）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建一个单线程的线程池.这个线程池只有一个核心线程工作,也就相当于单线程串行执行所有任务.如果这个唯一的线程因为异常结束,那么会有一个新的线程来替代它.此线程池保证所有的任务的执行顺序按照任务的提交顺序执行.<br><em>FixedThreadPool：</em>只有核心线程的线程池,大小固定（其缓冲队列是无界的）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorSerice <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建固定大小的线程池.每次提交一个任务就创建一个线程,直到线程达到线程池的最大大小.线程的大小一旦达到最大值就会保持不变,如果某个线程因为执行异常而结束,那么线程池会补充一个新的线程.<br><em>CachedThreadPool：</em>无界线程池,可以进行自动线程回收.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果线程池的大小超过了处理任务所需的线程,那么就会回收部分空闲（60秒不执行任务）的线程,当任务数增加时,此线程池又可以智能的添加新线程来处理任务.此线程池不会对线程池大小做限制,线程池大小完成依赖于操作系统（或者说JVM）能够创建的最大线程大小.<br><em>ScheduledThreadPool：</em>核心线程池固定,大小无限的线程池.此线程池支持定时以周期性执行任务的需求.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>创建一个周期性执行任务的线程池.如果闲置,非核心线程池会在DEFAULT_KEEPALIVE_MILLIS时间内回收.<br>线程池最常用的提交任务方法有两种：<br><em>execute：</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService.execute(Runnable runnable);</span><br></pre></td></tr></table></figure></p>
<p><em>submit：</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FutureTask task=ExecutorService.submit(Runnable runnable);</span><br><span class="line">FutureTask task=ExecutorService.submit(Runnable runnable,T Result);</span><br><span class="line">FutureTask task=ExecutorService.submit(Callable&lt;T&gt; callable);</span><br></pre></td></tr></table></figure></p>
<p>submit(Callable callable)的实现,submit(Runnable runnable)同理.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    FutureTask&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出submit开启的是有返回结果的任务,会返回一个FutureTask对像,这样就能通过get()方法得到结果.submit最终调用的也是execute(Runnable runnable),submit只是将Callable对象或Runnable封装成一个FutureFask对象,因为FutureTask是个Runnable,所以可以在execute中执行.关于Callable对象和Runnable怎么封装成FutureTask对象,见<a href="http://www.silencedut.com/2016/06/15/Callable%E5%92%8CFuture%E3%80%81FutureTask%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">Callable和Future、FutureTask的使用.</a></p>
<h2 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h2><p>如果只讲线程池的使用,那么招聘博客没有什么大的价值,充其量也就是熟悉Executor相关API的过程.程序池的实现过程没有用到synchronized关键字,用的都是volatile,Lock和同步(阻塞)队列,Atomic相关类,FutureTask等等,因为后者性能更优.理解的过程可以很好的学习源码中并发控制思想.</p>
<p>在开篇提到过线程池的优点是可以总结为一下三点：</p>
<ul>
<li>线程复用</li>
<li>控制最大并发数</li>
<li>管理线程</li>
</ul>
<ol>
<li><p><strong><em>线程复用过程</em></strong><br> 理解线程复用原理首先应了解线程的生命周期.<br> <img src="006tKfTcjw1f78hxvv1kmj30nm09c75z.jpg" alt=""><br> 在线程的生命周期中,它要经过新建(New)、就绪(Runnable)、运行(Running)、阻塞(Bloched)和死亡(Dead)5种状态.</p>
<p> Thread通过new来新建一个线程,这个过程是初始化一些线程信息,如线程名,id,线程所属group等,可以认为只是个普通的对象.调用Thread的start()后Java虚拟机会为其创建调用栈和程序计数器,同时将hasBeenStarted为true,之后调用start方法就会有异常.</p>
<p> 处于这个状态中的线程并没有开始运行,只是表示线程可以运行了.至于该线程何时开始运行,取决于JVM里线程调度器的调度.当线程获取cpu后,run()方法会被调用.不要自己去调用Thread的run()方法.之后根据CPU的调度在(就绪–运行–阻塞)间切换,直到run()方法结束或其他方式停止线程,进入dead状态.</p>
<p> 所以实现线程复用的原理应该就是要保持线程处于存活状态(就绪、运行、阻塞).接下来看看下ThreadPoolExecutor是怎么实现线程复用的.</p>
<p> 在ThreadPoolExecutor主要Worker类来控制线程的复用.开下Worker类简化后的代码,这样方便理解：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">	Runnable firstTask;</span><br><span class="line"></span><br><span class="line">	Worker(Runnable firstTask) &#123;</span><br><span class="line">		<span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">		<span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		runWorker(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">		Runnable task = w.firstTask;</span><br><span class="line">		w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">		    task.run();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Worker是一个Runnable,同时拥有一个thread,这个thread就是要开启的线程,在新建Worker对象时同时新建一个Thread对象,同时将Worker自己作为参数传入Thread,这样当Thread的start()方法调用时,运行的实际上是Worker的run()方法,接着到runWorker()中,有个while循环,一直从getTask()里得到Runnable对象,顺序执行.getTask()又是怎么得到Runnable对象得呢？依旧是简化后的代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(一些特殊情况) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Runnable r = workQueue.take();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这个workQueue就是初始化ThreadPoolExecutor时存放的任务的BlockingQueue队列,这个队列里的存放的都时将要执行的Runnable任务.因为BlockingQueue是个阻塞队列,BlockingQueue.task()得到如果是空,则进入等待状态直到BlockingQueue有新的对象被加入时唤醒阻塞的线程.所以一般情况Thread的run()方法就不会结束,而是不断的执行从workQueue里的Runnable任务,这就达到了线程复用的原理了.</p>
</li>
<li><p><strong><em>控制最大并发数</em></strong><br> 那Runnable是什么时候放入workQueue?Worker又是什么时候创建,Worker里的Thread的又是什么时候调用start()开启新线程来执行Worker的run()方法的呢？有上面的分析看出Worker里的runWorker()执行任务是一个接一个,串行进行的.那并发是怎么体现的呢？</p>
<p> 很容易想到是在execute(Runnable runnable)时会做上面的一些任务.看下execute里是怎么做的.</p>
<p> 简化后的代码 execute：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数 &lt; corePoolSize</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 直接启动新的线程.</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 活动线程数 &gt;= corePoolSize</span></span><br><span class="line">    <span class="comment">// runState为RUNNING &amp;&amp; 队列未满</span></span><br><span class="line">    <span class="comment">// workQueue.offer(command)表示添加到队列,如果添加成功返回true,否则返回   false</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次检验是否为RUNNING状态</span></span><br><span class="line">        <span class="comment">// 非RUNNING状态 则从workQueue中移除任务并拒绝</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);<span class="comment">// 采用线程池指定的策略拒绝任务</span></span><br><span class="line">        <span class="comment">// 两种情况：</span></span><br><span class="line">        <span class="comment">// 1.非RUNNING状态拒绝新的任务</span></span><br><span class="line">        <span class="comment">// 2.队列满了启动新的线程失败（workCount &gt; maximumPoolSize）</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 简化后的代码 addWorker：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">    <span class="keyword">if</span> (wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 根据代码再看上面提到的线程池工作过程中的添加任务的情况：</p>
<pre><code>1. 如果正在运行的线程数小于corePoolSize,那么马上创建线程运行这个任务；
2. 如果正在运行的线程数大于或等于corePoolSize,那么将这个任务放入队列；
3. 如果这个时候队列满了,而且正在运行的线程数量小于maximumPoolSize,那么还是要创建非核心线程立刻运行这个任务；
4. 如果队列满了,而且正在运行的线程数量大于或者等于maximumPoolSize,那么线程池会抛出异常RejectExecutionException.
</code></pre><blockquote>
<p>这就是Android的AsyncTask在并行执行是在超出最大任务数是抛出RejectExecutionException的原因所在,详见基于最新版本的AsyncTask源码解读及AsyncTask的黑暗面</p>
</blockquote>
<p> 通过addWorde如果成功创建新的线程成功,则通过start()开启新的线程,同时将firstTask作为这个Woker里的run()中执行的第一个任务.</p>
<p> 虽然每个Worker的任务都是串行处理的,但是如果创建多个Worker,因为是公用一个workQueue,所以就会并行处理了.</p>
<p> 所以根据corePoolSize和maximumPoolSize来控制最大并发数.大致过程可用下图表示.<br> <img src="006tKfTcgw1f79ope94y3j30nm0egdif.jpg" alt=""><br> 上面的讲解和图可以很好的理解的这个过程.</p>
<p> 如果是做Android开发的,并且对Handler原理比较熟悉,你可能会觉得这个图挺熟悉,其中的一些过程和Handler,Looper,Meaasge使用中,很相似.Handle.send(Message)相当于execute(Runnable),Looper中维护的Message队列相当于BlockingQueue,只不过需要自己通过同步来维护这个队列,Looper中的loop()函数循环从Message队列取Message和Worker中的runWork()不断从BlockingQueue取Runnable是同一的道理.</p>
</li>
<li><p><strong><em>管理线程</em></strong><br> 通过线程池可以很好的管理线程的复用,控制并发数,以及销毁等过程,线程的复用和控制并发上面已经讲了,而线程的管理过程已经穿插在其中了,也很好理解.</p>
<p> 在ThreadPoolExecutor有个ctl的AtomicInteger变量.通过这一个变量保存了两个内容：</p>
<pre><code>1. 所有线程的数量
2. 每个线程所处的状态
</code></pre><p> 其中低29位存线程数,高3位存runState,通过位运算来得到不同的值.</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到线程的状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到Worker的的数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线程是否在运行</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里主要通过shutdown和shutdownNow()来分析线程池的关闭过程.首先线程池有五种状态来控制任务添加与执行.主要介绍以下三种：</p>
<pre><code>1. RUNNING状态：线程池正常运行,可以接受新的任务并处理队列中的任务；
2. SHUTDOWN状态：不在接受新的任务,但是会执行队列中的任务；
3. STOP状态；不在接受新任务,不处理队列中的任务；
</code></pre><p> shutdown这个方法会将runState置为SHUNDOWN,会终止所有的空闲线程,而仍在工作的线程不受影响.所以队列中的任务人会被执行.shutdownNow方法runState置为STOP.和shutdown方法的区别,这个方法会终止所有的线程,所以队列中的任务也不会被执行了.</p>
</li>
</ol>
<h2 id="如何正确使用线程池"><a href="#如何正确使用线程池" class="headerlink" title="如何正确使用线程池"></a>如何正确使用线程池</h2><h3 id="避免使用无界队列"><a href="#避免使用无界队列" class="headerlink" title="避免使用无界队列"></a>避免使用无界队列</h3><p>不要使用Executors.newXXXThreadPool()快捷方法创建线程池,因为这种方式会使用无界的任务队列,为避免OOM,我们应该使用ThreadPoolExecutor的构造方法手动指定队列的最大长度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">2</span>, </span><br><span class="line">                <span class="number">0</span>, TimeUnit.SECONDS, </span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">512</span>), <span class="comment">// 使用有界队列,避免OOM</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br></pre></td></tr></table></figure></p>
<h3 id="明确拒绝任务时的行为"><a href="#明确拒绝任务时的行为" class="headerlink" title="明确拒绝任务时的行为"></a>明确拒绝任务时的行为</h3><p>任务队列总有占满的时候,这是再submit()提交新的任务会怎么样呢？RejectedExecutionHandler接口为我们提供了控制方式,接口定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="1521946099154-17b29e18-6853-4b39-8e2a-007ea89387bd.png" alt=""></p>
<table>
<thead>
<tr>
<th>拒绝策略</th>
<th>拒绝行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbortPolicy</td>
<td>抛出RejectedExecutionException</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>什么也不做,直接忽略</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃执行队列中最老的任务,尝试为当前提交的任务腾出位置</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>直接由提交任务者执行这个任务</td>
</tr>
</tbody>
</table>
<p>线程池默认的拒绝行为是AbortPolicy,也就是抛出RejectedExecutionHandler异常,该异常是非受检异常,很容易忘记捕获.如果不关心任务被拒绝的事件,可以将拒绝策略设置成DiscardPolicy,这样多余的任务会悄悄的被忽略.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">2</span>, </span><br><span class="line">                <span class="number">0</span>, TimeUnit.SECONDS, </span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">512</span>), </span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());<span class="comment">// 指定拒绝策略</span></span><br></pre></td></tr></table></figure>
<h3 id="获取处理结果和异常"><a href="#获取处理结果和异常" class="headerlink" title="获取处理结果和异常"></a>获取处理结果和异常</h3><p>线程池的处理结果、以及处理过程中的异常都被包装到Future中,并在调用Future.get()方法时获取,执行过程中的异常会被包装成ExecutionException,submit()方法本身不会传递结果和任务执行过程中的异常.获取执行结果的代码可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">Future&lt;Object&gt; future = executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"exception in call~"</span>);<span class="comment">// 该异常会在调用Future.get()时传递给调用者</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">     </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Object result = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">  <span class="comment">// interrupt</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">  <span class="comment">// exception in Callable.call()</span></span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池的常用场景"><a href="#线程池的常用场景" class="headerlink" title="线程池的常用场景"></a>线程池的常用场景</h2><h3 id="正确构造线程池"><a href="#正确构造线程池" class="headerlink" title="正确构造线程池"></a>正确构造线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> poolSize = Runtime.getRuntime().availableProcessors() * <span class="number">2</span>;</span><br><span class="line">BlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">512</span>);</span><br><span class="line">RejectedExecutionHandler policy = <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy();</span><br><span class="line">executorService = <span class="keyword">new</span> ThreadPoolExecutor(poolSize, poolSize,</span><br><span class="line">    <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">            queue,</span><br><span class="line">            policy);</span><br></pre></td></tr></table></figure>
<h3 id="获取单个结果"><a href="#获取单个结果" class="headerlink" title="获取单个结果"></a>获取单个结果</h3><p>过submit()向线程池提交任务后会返回一个Future,调用V Future.get()方法能够阻塞等待执行结果,V get(long timeout, TimeUnit unit)方法可以指定等待的超时时间.</p>
<h3 id="获取多个结果"><a href="#获取多个结果" class="headerlink" title="获取多个结果"></a>获取多个结果</h3><p>如果向线程池提交了多个任务,要获取这些任务的执行结果,可以依次调用Future.get()获得.但对于这种场景,我们更应该使用ExecutorCompletionService,该类的take()方法总是阻塞等待某一个任务完成,然后返回该任务的Future对象.向CompletionService批量提交任务后,只需调用相同次数的CompletionService.take()方法,就能获取所有任务的执行结果,获取顺序是任意的,取决于任务的完成顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(Executor executor, Collection&lt;Callable&lt;Result&gt;&gt; solvers)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    </span><br><span class="line">   CompletionService&lt;Result&gt; ecs = <span class="keyword">new</span> ExecutorCompletionService&lt;Result&gt;(executor);<span class="comment">// 构造器</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">for</span> (Callable&lt;Result&gt; s : solvers)<span class="comment">// 提交所有任务</span></span><br><span class="line">       ecs.submit(s);</span><br><span class="line">        </span><br><span class="line">   <span class="keyword">int</span> n = solvers.size();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;<span class="comment">// 获取每一个完成的任务</span></span><br><span class="line">       Result r = ecs.take().get();</span><br><span class="line">       <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">           use(r);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单个任务的超时时间"><a href="#单个任务的超时时间" class="headerlink" title="单个任务的超时时间"></a>单个任务的超时时间</h3><p>V Future.get(long timeout, TimeUnit unit)方法可以指定等待的超时时间,超时未完成会抛出TimeoutException.</p>
<p>多个任务的超时时间<br>等待多个任务完成,并设置最大等待时间,可以通过CountDownLatch完成：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLatch</span><span class="params">(ExecutorService executorService, List&lt;Runnable&gt; tasks)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">       </span><br><span class="line">    CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(tasks.size());</span><br><span class="line">      <span class="keyword">for</span>(Runnable r : tasks)&#123;</span><br><span class="line">          executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">try</span>&#123;</span><br><span class="line">                      r.run();</span><br><span class="line">                  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                      latch.countDown();<span class="comment">// countDown</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      latch.await(<span class="number">10</span>, TimeUnit.SECONDS); <span class="comment">// 指定超时时间</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="线程池和装修公司"><a href="#线程池和装修公司" class="headerlink" title="线程池和装修公司"></a>线程池和装修公司</h2><p>以运营一家装修公司做个比喻.公司在办公地点等待客户来提交装修请求；公司有固定数量的正式工以维持运转；旺季业务较多时,新来的客户请求会被排期,比如接单后告诉用户一个月后才能开始装修；当排期太多时,为避免用户等太久,公司会通过某些渠道（比如人才市场、熟人介绍等）雇佣一些临时工（注意,招聘临时工是在排期排满之后）；如果临时工也忙不过来,公司将决定不再接收新的客户,直接拒单.</p>
<p>线程池就是程序中的“装修公司”,代劳各种脏活累活.上面的过程对应到线程池上：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java线程池的完整构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> corePoolSize, // 正式工数量</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> maximumPoolSize, // 工人数量上限,包括正式工和临时工</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">long</span> keepAliveTime, TimeUnit unit, // 临时工游手好闲的最长时间,超过这个时间将被解雇</span></span></span><br><span class="line"><span class="function"><span class="params">  BlockingQueue&lt;Runnable&gt; workQueue, // 排期队列</span></span></span><br><span class="line"><span class="function"><span class="params">  ThreadFactory threadFactory, // 招人渠道</span></span></span><br><span class="line"><span class="function"><span class="params">  RejectedExecutionHandler handler // 拒单方式</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="如何合理地估算线程池大小"><a href="#如何合理地估算线程池大小" class="headerlink" title="如何合理地估算线程池大小?"></a>如何合理地估算线程池大小?</h2><p>这个问题虽然看起来很小,却并不那么容易回答.大家如果有更好的方法欢迎赐教,先来一个天真的估算方法：假设要求一个系统的TPS（Transaction Per Second或者Task Per Second,tps是每秒内的事务数,比如执行了dml操作,那么相应的tps会增加）至少为20,然后假设每个Transaction由一个线程完成,继续假设平均每个线程处理一个Transaction的时间为4s.那么问题转化为：</p>
<h3 id="如何设计线程池大小-使得可以在1s内处理完20个Transaction"><a href="#如何设计线程池大小-使得可以在1s内处理完20个Transaction" class="headerlink" title="如何设计线程池大小,使得可以在1s内处理完20个Transaction?"></a>如何设计线程池大小,使得可以在1s内处理完20个Transaction?</h3><p>计算过程很简单,每个线程的处理能力为0.25TPS(1s/4s),那么要达到20TPS,显然需要20/0.25=80个线程.</p>
<p>很显然这个估算方法很天真,因为它没有考虑到CPU数目.一般服务器的CPU核数为16或者32,如果有80个线程,那么肯定会带来太多不必要的线程上下文切换开销.</p>
<p>再来第二种简单的但不知是否可行的方法(N为CPU总核数):</p>
<ol>
<li>如果是CPU密集型应用,则线程池大小设置为N+1</li>
<li>如果是IO密集型应用,则线程池大小设置为2N+1</li>
</ol>
<p><strong>如果一台服务器上只部署这一个应用并且只有这一个线程池,那么这种估算或许合理,具体还需自行测试验证.</strong></p>
<p>接下来在这个文档：服务器性能IO优化 中发现一个估算公式：</p>
<blockquote>
<p>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</p>
</blockquote>
<p>比如平均每个线程CPU运行时间为0.5s,而线程等待时间（非CPU运行时间,比如IO）为1.5s,CPU核心数为8,那么根据上面这个公式估算得到：((0.5+1.5)/0.5)*8=32.这个公式进一步转化为：</p>
<blockquote>
<p>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</p>
</blockquote>
<p>可以得出一个结论：<br><strong>线程等待时间所占比例越高(IO密集型),需要越多线程.线程CPU时间所占比例越高(CPU密集型),需要越少线程.</strong></p>
<p>上一种估算方法也和这个结论相合.<br>一个系统最快的部分是CPU,所以决定一个系统吞吐量上限的是CPU。增强CPU处理能力,可以提高系统吞吐量上限。但根据短板效应,真实的系统吞吐量并不能单纯根据CPU来计算。那要提高系统吞吐量,就需要从“系统短板”（比如网络延迟、IO）着手：</p>
<ol>
<li>尽量提高短板操作的并行化比率,比如多线程下载技术</li>
<li>增强短板能力,比如用NIO替代IO</li>
</ol>
<p>第一条可以联系到Amdahl定律,这条定律定义了串行系统并行化后的加速比计算公式：</p>
<blockquote>
<p>加速比=优化前系统耗时 / 优化后系统耗时</p>
</blockquote>
<p>加速比越大,表明系统并行化的优化效果越好。Addahl定律还给出了系统并行度、CPU数目和加速比的关系,加速比为Speedup,系统串行化比率（指串行执行代码所占比率）为F,CPU数目为N</p>
<blockquote>
<p>Speedup &lt;= 1 / (F + (1-F)/N)</p>
</blockquote>
<p>当N足够大时,串行化比率F越小,加速比Speedup越大.</p>
<p><strong>是否使用线程池就一定比使用单线程高效呢?</strong></p>
<p>答案是否定的,比如Redis就是单线程的,但它却非常高效,基本操作都能达到十万量级/s。从线程这个角度来看,部分原因在于:<br>多线程带来线程上下文切换开销,单线程就没有这种开销锁</p>
<p>当然“Redis很快”更本质的原因在于：Redis基本都是内存操作,这种情况下单线程可以很高效地利用CPU。而多线程适用场景一般是：存在相当比例的IO和网络操作.</p>
<p>所以即使有上面的简单估算方法,也许看似合理,但实际上也未必合理,都需要结合系统真实情况（比如是IO密集型或者是CPU密集型或者是纯内存操作）和硬件环境（CPU、内存、硬盘读写速度、网络状况等）来不断尝试达到一个符合实际的合理估算值.</p>
<p>最后来一个“Dark Magic”估算方法(因为我暂时还没有搞懂它的原理),使用下面的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.RoundingMode;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolSizeCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The sample queue size to calculate the size of a single &#123;<span class="doctag">@link</span> Runnable&#125; element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SAMPLE_QUEUE_SIZE = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Accuracy of test run. It must finish within 20ms of the testTime otherwise we retry the test. This could be</span></span><br><span class="line"><span class="comment">     * configurable.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> EPSYLON = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Control variable for the CPU time investigation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> expired;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Time (millis) of the test run in the CPU time calculation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> testtime = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calculates the boundaries of a thread pool for a given &#123;<span class="doctag">@link</span> Runnable&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetUtilization    the desired utilization of the CPUs (0 &lt;= targetUtilization &lt;= 1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetQueueSizeBytes the desired maximum work queue size of the thread pool (bytes)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">calculateBoundaries</span><span class="params">(BigDecimal targetUtilization, BigDecimal targetQueueSizeBytes)</span> </span>&#123;</span><br><span class="line">        calculateOptimalCapacity(targetQueueSizeBytes);</span><br><span class="line">        Runnable task = creatTask();</span><br><span class="line">        start(task);</span><br><span class="line">        start(task); <span class="comment">// warm up phase</span></span><br><span class="line">        <span class="keyword">long</span> cputime = getCurrentThreadCPUTime();</span><br><span class="line">        start(task); <span class="comment">// test intervall</span></span><br><span class="line">        cputime = getCurrentThreadCPUTime() - cputime;</span><br><span class="line">        <span class="keyword">long</span> waittime = (testtime * <span class="number">1000000</span>) - cputime;</span><br><span class="line">        calculateOptimalThreadCount(cputime, waittime, targetUtilization);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculateOptimalCapacity</span><span class="params">(BigDecimal targetQueueSizeBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> mem = calculateMemoryUsage();</span><br><span class="line">        BigDecimal queueCapacity = targetQueueSizeBytes.divide(<span class="keyword">new</span> BigDecimal(mem), RoundingMode.HALF_UP);</span><br><span class="line">        System.out.println(<span class="string">"Target queue memory usage (bytes): "</span> + targetQueueSizeBytes);</span><br><span class="line">        System.out.println(<span class="string">"createTask() produced "</span> + creatTask().getClass().getName() + <span class="string">" which took "</span> + mem</span><br><span class="line">                + <span class="string">" bytes in a queue"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Formula: "</span> + targetQueueSizeBytes + <span class="string">" / "</span> + mem);</span><br><span class="line">        System.out.println(<span class="string">"* Recommended queue capacity (bytes): "</span> + queueCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Brian Goetz' optimal thread count formula, see 'Java Concurrency in Practice' (chapter 8.2)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cpu               cpu time consumed by considered task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wait              wait time of considered task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetUtilization target utilization of the system</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calculateOptimalThreadCount</span><span class="params">(<span class="keyword">long</span> cpu, <span class="keyword">long</span> wait, BigDecimal targetUtilization)</span> </span>&#123;</span><br><span class="line">        BigDecimal waitTime = <span class="keyword">new</span> BigDecimal(wait);</span><br><span class="line">        BigDecimal computeTime = <span class="keyword">new</span> BigDecimal(cpu);</span><br><span class="line">        BigDecimal numberOfCPU = <span class="keyword">new</span> BigDecimal(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        BigDecimal optimalthreadcount = numberOfCPU.multiply(targetUtilization).multiply(</span><br><span class="line">                <span class="keyword">new</span> BigDecimal(<span class="number">1</span>).add(waitTime.divide(computeTime, RoundingMode.HALF_UP)));</span><br><span class="line">        System.out.println(<span class="string">"Number of CPU: "</span> + numberOfCPU);</span><br><span class="line">        System.out.println(<span class="string">"Target utilization: "</span> + targetUtilization);</span><br><span class="line">        System.out.println(<span class="string">"Elapsed time (nanos): "</span> + (testtime * <span class="number">1000000</span>));</span><br><span class="line">        System.out.println(<span class="string">"Compute time (nanos): "</span> + cpu);</span><br><span class="line">        System.out.println(<span class="string">"Wait time (nanos): "</span> + wait);</span><br><span class="line">        System.out.println(<span class="string">"Formula: "</span> + numberOfCPU + <span class="string">" * "</span> + targetUtilization + <span class="string">" * (1 + "</span> + waitTime + <span class="string">" / "</span></span><br><span class="line">                + computeTime + <span class="string">")"</span>);</span><br><span class="line">        System.out.println(<span class="string">"* Optimal thread count: "</span> + optimalthreadcount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Runs the &#123;<span class="doctag">@link</span> Runnable&#125; over a period defined in &#123;<span class="doctag">@link</span> #testtime&#125;. Based on Heinz Kabbutz' ideas</span></span><br><span class="line"><span class="comment">     * (http://www.javaspecialists.eu/archive/Issue124.html).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the runnable under investigation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> runs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (++runs &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Test not accurate"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            expired = <span class="keyword">false</span>;</span><br><span class="line">            start = System.currentTimeMillis();</span><br><span class="line">            Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">            timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    expired = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, testtime);</span><br><span class="line">            <span class="keyword">while</span> (!expired) &#123;</span><br><span class="line">                task.run();</span><br><span class="line">            &#125;</span><br><span class="line">            start = System.currentTimeMillis() - start;</span><br><span class="line">            timer.cancel();</span><br><span class="line">        &#125; <span class="keyword">while</span> (Math.abs(start - testtime) &gt; EPSYLON);</span><br><span class="line">        collectGarbage(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectGarbage</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calculates the memory usage of a single element in a work queue. Based on Heinz Kabbutz' ideas</span></span><br><span class="line"><span class="comment">     * (http://www.javaspecialists.eu/archive/Issue029.html).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> memory usage of a single &#123;<span class="doctag">@link</span> Runnable&#125; element in the thread pools work queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">calculateMemoryUsage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; queue = createWorkQueue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SAMPLE_QUEUE_SIZE; i++) &#123;</span><br><span class="line">            queue.add(creatTask());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> mem0 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        <span class="keyword">long</span> mem1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        queue = <span class="keyword">null</span>;</span><br><span class="line">        collectGarbage(<span class="number">15</span>);</span><br><span class="line">        mem0 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        queue = createWorkQueue();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SAMPLE_QUEUE_SIZE; i++) &#123;</span><br><span class="line">            queue.add(creatTask());</span><br><span class="line">        &#125;</span><br><span class="line">        collectGarbage(<span class="number">15</span>);</span><br><span class="line">        mem1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class="line">        <span class="keyword">return</span> (mem1 - mem0) / SAMPLE_QUEUE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create your runnable task here.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an instance of your runnable task under investigation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Runnable <span class="title">creatTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return an instance of the queue used in the thread pool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> queue instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> BlockingQueue&lt;Runnable&gt; <span class="title">createWorkQueue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Calculate current cpu time. Various frameworks may be used here, depending on the operating system in use. (e.g.</span></span><br><span class="line"><span class="comment">     * http://www.hyperic.com/products/sigar). The more accurate the CPU time measurement, the more accurate the results</span></span><br><span class="line"><span class="comment">     * for thread count boundaries.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> current cpu time of current thread</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getCurrentThreadCPUTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后自己继承这个抽象类并实现它的三个抽象方法,比如下面是我写的一个示例（任务是请求网络数据）,其中我指定期望CPU利用率为1.0（即100%）,任务队列总大小不超过100,000字节:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.lang.management.ManagementFactory;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePoolSizeCaculatorImpl</span> <span class="keyword">extends</span> <span class="title">PoolSizeCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Runnable <span class="title">creatTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncIOTask();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> BlockingQueue <span class="title">createWorkQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getCurrentThreadCPUTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PoolSizeCalculator poolSizeCalculator = <span class="keyword">new</span> SimplePoolSizeCaculatorImpl();</span><br><span class="line">        poolSizeCalculator.calculateBoundaries(<span class="keyword">new</span> BigDecimal(<span class="number">1.0</span>), <span class="keyword">new</span> BigDecimal(<span class="number">100000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的异步IO任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Will</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncIOTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpURLConnection connection = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String getURL = <span class="string">"http://www.baidu.com"</span>;</span><br><span class="line">            URL getUrl = <span class="keyword">new</span> URL(getURL);</span><br><span class="line"></span><br><span class="line">            connection = (HttpURLConnection) getUrl.openConnection();</span><br><span class="line">            connection.connect();</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                    connection.getInputStream()));</span><br><span class="line"></span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// empty loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            connection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>得到的输出如下:<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Target queue memory usage (bytes): 100000</span><br><span class="line">createTask() produced com.example.demo.threadpool.AsyncIOTask which took 40 bytes in a queue</span><br><span class="line">Formula: 100000 / 40</span><br><span class="line">* Recommended queue capacity (bytes): 2500</span><br><span class="line">Disconnected from the target VM, address: '127.0.0.1:57093', transport: 'socket'</span><br><span class="line">Number of CPU: 8</span><br><span class="line">Target utilization: 1</span><br><span class="line">Elapsed time (nanos): 3000000000</span><br><span class="line">Compute time (nanos): 93750000</span><br><span class="line">Wait time (nanos): 2906250000</span><br><span class="line">Formula: 8 * 1 * (1 + 2906250000 / 93750000)</span><br><span class="line">* Optimal thread count: 256</span><br></pre></td></tr></table></figure></p>
<p>推荐的任务队列大小为2500,线程数为256,有点出乎意料之外。我可以如下构造一个线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor pool =</span><br><span class="line"> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">256</span>, <span class="number">256</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">2500</span>));</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Executors为我们提供了构造线程池的便捷方法,对于服务器程序我们应该杜绝使用这些便捷方法,而是直接使用线程池ThreadPoolExecutor的构造方法,避免无界队列可能导致的OOM以及线程个数限制不当导致的线程数耗尽等问题.ExecutorCompletionService提供了等待所有任务执行结束的有效方式,如果要设置等待的超时时间,则可以通过CountDownLatch完成.</p>
<p>通过对ThreadPoolExecutor源码的分析,从总体上了解了线程的创建,任务的添加,执行等过程,熟悉这些过程,使用线程池就会更新松了.<br>而从中学到的一些对并发控制,以及生产者–消费者模型任务处理器的使用,对以后理解或解决其他相关问题会有很大的帮助.比如Android中的Handler机制,而Looper中的Messager队列用一个BlookQueue来处理同样是可以的,这些就是读源码的收获吧</p>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[守护线程]]></title>
      <url>http://kxh.ink/2017/02/16/Daemon-Thread/</url>
      <content type="html"><![CDATA[<p>有时候，你希望创建一个线程来执行一些辅助工作，但又不希望这个线程阻碍JVM的关闭。在这种情况下就需要使用守护线程（Daemon Thread）。<br>线程可分为两种：普通线程和守护线程。在JVM启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程（例如垃圾回收器以及其他执行辅助工作的线程）。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。<br>普通线程与守护线程之间的差异仅在于当线程退出时发生的操作。当一个线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM会正常退出操作。当JVM停止时，所有仍然存在的守护线程都将抛弃–既不会执行finally代码块，也不会执行回卷栈，而JVM只是直接退出。<br>我们应尽可能少的使用守护线程–很少操作能在不进行清理的情况下被安全的抛弃。特别是，如果在守护线程中执行可能包含I/O操作的任务，那么将是一种危险的行为。守护线程最好用于执行“内部”任务，例如周期性地从内存缓存中移除逾期的数据。</p>
<blockquote>
<p><strong>此外，守护线程通常不能用来代替应用程序管理程序中各个服务的生命周期。</strong><br><a id="more"></a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> Java 并发编程实战 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java中的参数传递——值传递、引用传递]]></title>
      <url>http://kxh.ink/2017/02/15/Pass-By-Value/</url>
      <content type="html"><![CDATA[<p>首先，不要纠结于Pass By Value 和 Pass By Reference 的字面上的意义，否则很容易陷入所谓的“一切传引用其本质上是传值”这种并不能解决问题毫无意义论战中。更何况，要想知道Java到底是传值还是传引用，起码你要先知道传值和传引用的准确含义吧？可是如果你已经知道了这两个名字的准确含义，那么你自己就能判断Java到底是传值还传引用。这个好像用大学的名词来解释高中的题目，对于初学者根本没有任何意义。<br><a id="more"></a></p>
<ul>
<li>搞清楚基本类型和引用类型的不同之处<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br><span class="line">``` </span><br><span class="line">![](<span class="number">166032</span>bc90958c21604110441ad03f45_r.jpg)  </span><br><span class="line">如图所示，num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保持的只是实际对象的地址。一般称这种变量为“引用”，引用指向实际对象，实际对象中保存着内容。</span><br><span class="line"></span><br><span class="line">- 搞清楚赋值运算符（=）的作用  </span><br><span class="line">``` java </span><br><span class="line">num = <span class="number">20</span>;</span><br><span class="line">str = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="287c0efbb179638cf4cf27cbfdf3e746_b.jpg" alt=""> </p>
<p>对于基础类型num，赋值运算符会直接改变变量的值，原来的值被覆盖掉。<br>对于引用类型str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。<strong>但是原来的对象不会被改变（重要）。</strong><br>如上图所示，“hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）  </p>
<ul>
<li>调用方法时候发生了什么？<strong>参数传递基本上就是赋值操作。</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个例子：基础类型 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    value = <span class="number">100</span>；</span><br><span class="line">&#125;</span><br><span class="line">foo(num);<span class="comment">//num 没有被改变 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个例子：没有提供改变自身方法的引用类型 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">    text =<span class="string">"windows"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(str);<span class="comment">//str 也没被改变 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三个例子：提供了改变自身方法的引用类型</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span></span>&#123;</span><br><span class="line">    builder.append(<span class="string">"4"</span>);</span><br><span class="line">&#125; </span><br><span class="line">foo(sb);<span class="comment">//sb 被改变了，变成了“iphone4”。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第四个例子：提供了改变自身方法的引用类型，但是不是使用，而是使用赋值运算符。</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span></span>&#123;</span><br><span class="line">    builder = <span class="keyword">new</span> StringBuilder(<span class="string">"ipad"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb);<span class="comment">//sb 没有被改变，还是“iphone”。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>重点理解为什么，第三个例子和第四例子结果不同？<br>下面是第三个例子的图解：<br><img src="d8b82e07ea21375ca6b300f9162aa95f_b.jpg" alt=""></p>
<p>builder.append(“4”)之后</p>
<p><img src="ff2ede9c6c55568d42425561f25a0fd7_b.jpg" alt=""></p>
<p>下面是第四个例子的图解：</p>
<p><img src="d8b82e07ea21375ca6b300f9162aa95f_b.jpg" alt=""></p>
<p>builder = new StringBuilder(“ipad”);之后</p>
<p><img src="46fa5f10cc135a3ca087dae35a5211bd_b.jpg" alt=""> </p>
<p>2017-02-15 11:09:20 康兴华<br>发现以前一直以来的理解都是错误的，单纯说方法传递是传值和和传引用毫无意义的。</p>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 内存模型]]></title>
      <url>http://kxh.ink/2017/01/13/happen-before/</url>
      <content type="html"><![CDATA[<h2 id="happen-before-规则介绍"><a href="#happen-before-规则介绍" class="headerlink" title="happen-before 规则介绍"></a>happen-before 规则介绍</h2><p>Java 语言中有一个“先行发生”（happen-before）的规则，它是Java内存模型中定义的两项操作之间的关系，如果操作A先行发生于B，其意思就是说，在发生操作B之前，操作A产生的影响都能被操作B观察到，“影响”包括修改了内存中的共享变量的值、发送了消息、调用了方法等，它与时间的先后发生基本没有太大关系。z合格原则特别重要，它是判断数据是否存在竞争、线程是否安全的重要以及。<br><a id="more"></a><br>举个栗子，假设存在如下三个线程，分别执行对应的操作： </p>
<ul>
<li>线程A中执行如下操作：i=1</li>
<li>线程B中执行如下操作：j=i</li>
<li>线程C中执行如下操作：i=2   </li>
</ul>
<p>假设线程A中的操作“i=1”happen-before线程B中的操作“j=i”，那么久可以保证线程B的操作执行后，变量j的值一定为1，即线程B观察到了线程A中的操作“i=1”所产生的影响；现在，我们依然保持线程A和线程B之间的happen-before关系，同时线程C出现在了线程A和线程B的操作之间，但是C和B并没有happen-before关系，那么j的值就不确定了，线程C对变量i的影响可能会被线程B观察到，也可能不会，这时线程B就存在读取到不是最新数据的风险，不具备线程安全性。  </p>
<p>下面是Java内存模型中的八条可保证happen-before的规则，它们无需任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随机的重排序。  </p>
<ul>
<li>程序次序规则：在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作happen-before（时间上）后执行的操作。</li>
<li>管理锁定规则：一个unlock操作happen-before后面（时间上的先后顺序，下同）对同一个锁的lock操作。</li>
<li>volatile变量规则：对一个volatile变量的写操作happen-before后面对改变量的读操作。</li>
<li>线程启动规则：Thread对象的start()方法happen-before此线程的每一个动作。</li>
<li>线程终止规则：线程所有的操作都happen-before对此线程的终止检测，可以通过Thread.join()方法结束Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则：对线程interrupt()方法调用happen-before发生于被中断线程的代码检测到中断时事件的发生。</li>
<li>对象终结规则：一个对象的初始化完成（构造函数执行结束）happen-before它的finalize()方法的开始。</li>
<li><strong>传递性：如果操作A happen-before 操作B，操作B happen-before 操作C，那么可以得出A happen-before 操作C</strong></li>
</ul>
<h2 id="时间上先后顺序和happen-before原则"><a href="#时间上先后顺序和happen-before原则" class="headerlink" title="时间上先后顺序和happen-before原则"></a>时间上先后顺序和happen-before原则</h2><p>“时间上执行的先后顺序”与“happen-before”之间有何不同呢？<br>首先来看操作A在时间上先于操作B发生，是否意味着操作A happen-before 操作B？<br>一个常用来分析的例子如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value=value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设存在线程A和线程B，线程A先（时间上的先）调用了setValue(3)操作，然后（时间上的后）线程B调用了同一对象的getValue()方法，那么线程B得到的返回值一定是3吗？  </p>
<p>对照以上八条happen-before规则，发现没有一条规则适合这里的value变量，从而我们可以判断线程A中的setValue(3)操作与线程B中的getValue()操作不存在happen-before关系。因此，尽管线程A的setValue(3)在操作时间上预先于操作B的getValue()，但无法保证线程B的getValue()操作一定观察到了线程A的setValue(3)操作所产生的结果，也就是getValue()的返回值不一定为3（有可能是之前setValue所设置的值）。这里的操作不是线程安全的。  </p>
<p>因此，“一个操作时间上先发生于另一个操作”并不代表“一个操作happen-before另一个操作”。  </p>
<p>解决方法：可以将setValue(int)方法和getValue()方法均定义为synchronized方法，也可以把value定义为volatile变量（value的修改并不依赖value的原始值,符合volatile的使用场景），分别对应happen-before规则的第2和第3条。注意，只将setValue(int)方法和getValue方法中的一个定义为synchronized方法是不行，必须对同一个变量的所有读写同步，才能保证不读取到陈旧的数据，仅仅同步读或写是不够的。  </p>
<p>其次来看，操作A happen-before 操作B，是否意味着操作A在时间上先与操作B发生？</p>
<p>看有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>假设同一个线程执行上面的两个操作：操作A：x=1 和操作B：y=2。根据happen-before 规则的第1条，操作A happen-before 操作B，但是由于编译器的指令重新排序（Java 语言规范规定了JVM线程内部维持顺序化语义，也就是说只要程序最终结果等同于它在严格的顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致。这个过程通过叫做指令的重排序.指令重排序存在的意义在于：JVM能够根据处理器的特性“CPU的多级缓存系统，多核处理器等”适当的重新排序机器指令，使机器指令更符合CPU的执行特点，最大限度的发挥机器的性能。在没有同步的情况下编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整）等原因，操作A在时间上有可能后与操作B被处理器执行，但这并不影响happen-before原则的正确性。</p>
<p>因此，“一个操作happen-before另一个操作”并不代表“一个操作时间上先发生于另一个操作”。</p>
<p>最后，一个操作和另一个操作必定存在某个顺序，要么一个操作或者是先于后一个操作，或者与两个操作同时发生。同时发生时完全有可能存在的，特别是在多CPU的情况下。而两个操作之间却可能没有happen-before关系，也就是说有可能发生这样的情况，操作A不happen-before操作B，操作B也不happen-before操作A，用数学上的术语happen-before关系是个偏序关系。两个存在happen-before关系的操作不可能同时发生，一个操作A happen-before操作B，它们必定在时间上市完全错开的，这实际上也是同步语义之一（独占访问）。</p>
<h2 id="利用happen-before-规则分析-DCL"><a href="#利用happen-before-规则分析-DCL" class="headerlink" title="利用happen-before 规则分析 DCL"></a>利用happen-before 规则分析 DCL</h2><p>DCL 即双重检查加锁，下面是一个典型额单例模式中使用DCL的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> someField;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.someField = <span class="keyword">new</span> Random().nextInt(<span class="number">200</span>)+<span class="number">1</span>;         <span class="comment">// (1)  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                               <span class="comment">// (2)  </span></span><br><span class="line">            <span class="keyword">synchronized</span>(LazySingleton.class) &#123;               <span class="comment">// (3)  </span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;                       <span class="comment">// (4)  </span></span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleton();           <span class="comment">// (5)  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;                                      <span class="comment">// (6)  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSomeField</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.someField;                                <span class="comment">// (7)  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里得到单一的instance实例是没有问题的。问题的关键在于尽管得了Singleton的正确引用，但是却有可能访问到其成员变量的不正确值。具体来说Singleton.getInstance().getSomeField()有可能返回someField的默认值0。如果程序行为正确的话，这应当时不可能发生的事，因为构造函数里设置的someField的值不可能为0。为了说明这种情况理论上有可能发生，我们只需要说明语句(1)和语句(7)并不存在happen-before关系。</p>
<p>假设线程A是初次调用getInstance()方法，紧接着线程B也调用了getInstance()方法和getSomeField()方法，我们要说明的是线程A的语句(1)并不happen-before线程B的语句(7)。线程B在执行getInstance()方法的语句(2)时，由于对instance的访问并没有处于同步块中，因此线程B可能观察到也可能观察不到线程A在语句(5)时对instance的写入，也就是说instance的值可能为空也可能非空。我们先假设instance的值非空，也就观察到了线程A对instance的写入，这时线程B就会执行语句(6)直接返回这个instance的值，然后对这个instance调用getSomeField()方法，该方法也是在没有任何同步情况下被调用，因此整个线程B操作都是在没有同步的情况下调用，这时我们便无法利用上述8条happen-before规则得到线程A的操作和线程B的操作之间的任何有效的happen-before关系（主要考虑规则的第2条，但由于线程B没有在进入synchronized块，因此不存在lock与unlock锁的问题），这说明线程A的语句(1)和线程B的语句(7)之间不存在happen-before关系，这就意味着线程B在执行语句(7)完全有可能观测不到线程A在语句(1)处对somefield写入的值，这就是DCL的问题所在。很荒谬，是吧？DCL原本是为了逃避同步，他达到了这个目的，也正因为如此，它最终受到了惩罚，这样的程序存在严重的bug，虽然这种bug被发现的概率绝对比中彩票的概率还要低得多，而且瞬间即逝，更可怕的是，即使发生了你也不会想到是DCL所引起的。  </p>
<p>前面我们说了，线程B在执行语句(2)时也有可能观察到空值，如果是这种情况，那么它需要进入同步块，并执行语句(4)。在语句(4)处线程B还能够读到instance的空值吗？是不可能，这里因为这时对instance的读写都是发生在同一个锁定的同步块中。这时读到的数据是最新数据。为了加深印象，我再用happen-before规则分析一遍。线程B在语句(3)处会执行一个lock操作，而线程A在语句(5)后会执行unlock操作，这两个操作都是针对同一个锁–Singleton.class，因此根据第2条happen-before规则，线程A的unlock操作happen-before线程B的lock操作，在利用单线程规则，线程A的语句(5)-&gt;线程A的unlock操作，线程B的lock操作-&gt;线程B的语句(4)，在根据传递规则，就有线程A的语句(5)-&gt;线程B的语句(4)，也就是说线程B在执行语句(4)的时候能观察到线程A在语句(5)时对Singleton的写入值。接着对返回的instance调用getSomeField()方法时，我们也能得到线程A的语句(1)-&gt;线程B的语句(7)(由于线程B有进入synchronized块，根据规则2可得)，这表明这个时getSomeField()能够得到正确的值。但是仅仅是这种情况的正确性并不妨碍DCL的不正确性，一个程序的正确性必须在所有情况下的行为都是正确的，而不能有时正确，有时不正确。  </p>
<p>对DCL的分析也告诉我们一条经验原则：对引用（包括对象引用和数组引用）的非同步访问，即使得到该引用的最新值，却并不能保证也能得到其成员变量（对数组而言就是每个数组元素）的最新值。  </p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>最简单而且安全的解决方法是使用static内部类的思想，它利用的思想是：一个类直到被使用时才被初始化，而类初始化过程是非并行的，这些都有JLS（java语言规范）保证。  </p>
<p>如下代码：</p>
<pre><code class="Java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  

  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{}  

  <span class="comment">// Lazy initialization holder class idiom for static fields  </span>
  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>{  
   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  
  }  

  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>{   
    <span class="keyword">return</span> InstanceHolder.instance;   
  }  
}
</code></pre>
<p>另外，可以将instance声明为volatile，即<br><strong>private volatile static LazySingleton instance;</strong><br>这样我们便可以得到，线程A的语句(5)-&gt;线程B的语句(2),根据单线程规则，线程A的语句(1)-&gt;线程A的语句(5)和线程B的语句(2)-&gt;线程B的语句(7)，再根据传递规则就有线程A的语句(1)-&gt;线程B的语句(7),这表示线程B能观察到线程A在语句(1)时对somefiled的写入值，程序能够得到正确的行为。  </p>
<blockquote>
<p>注：<br>1.volatile屏蔽指令重排序的语义在JDK1.5中财被完全修复，此前的JDK中即使变量声明为volatile，也仍然不能完全避免重排序所导致的问题（主要是volatile变量前后的代码仍然存在重排序问题），这点也是在JDK1.5之前的Java中无法安全的使用DCL来实现单例模式的原因。  </p>
<p>2.把volatile写和volatile读这两个操作综合起来看，在线程B读一个volatile变量后，写线程A在写这个volatile变量之前，所有可见的共享变量值都将立即变得对读线程B可见。  </p>
<p>3.在 java5 之前对 final 字段的同步语义和其它变量没有什么区别，在 java5 中，final 变量一旦在构造函数中设置完成（前提是在构造函数中没有泄露 this 引用)，其它线程必定会看到在构造函数中设置的值。而 DCL 的问题正好在于看到对象的成员变量的默认值，因此我们可以将 LazySingleton的someField 变量设置成 final，这样在 java5 中就能够正确运行了。</p>
</blockquote>
<h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>Java 内存模型主要目的是定义程序中各个变量访问规则，即在虚拟机中变量存储到内存和从内存中取出变量这样的底层细节。此处变量主要是指内存共享变量，存在竞争问题的变量。Java内存模型规定变量都存储在主内存中，而每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等）都必须在工作内存中进行，而不能直接读写主内存中变量（根据Java虚拟机规范规定，volatile变量依然有共享内存拷贝，但是由于它特殊的操作顺序规定–从工作内存中读写数据前，必须先将内存中的数据同步到工作内存中，所有看起来如同直接在主内存读写访问一般，因此这里的描述对于volatile也不例外）。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存完成。  </p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p><strong>Java 内存模型中定义了以下8种操作来完成主内存与工作内存之间交互的实现细节：</strong>  </p>
<ul>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标示为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后变量才可以被其他线程锁定。  </li>
<li>read（读取）：作用于主内存变量，它把一个变量的值从内存传输到工作内存中，以便随后的load动作使用。 </li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 </li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到的变量的值的字节码指令时将会执行这个操作。  </li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。  </li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传递到主内存中，以便随后write操作使用。 </li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量值放入主内存的变量中。  </li>
</ul>
<p><strong>Java 内存模型还规定了执行上述8种基本操作时必须满足如下规则：</strong>  </p>
<ul>
<li>不允许（read和load）、（store和write）操作之一单独出现，以上两个操作必须按顺序执行，但没有保证必须连续执行，也就是说，（read与load之间）、（store与write之间）是可以插入其他指令的。  </li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。  </li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存。 </li>
<li>一个新的变量只能从主内存中“诞生”，不允许在工作内存中直接使用已个未被初始化（load或assign）的变量，换句话说就是一个变量实施use和store操作之前，必须先执行过了assign和load操作。  </li>
<li>一个变量在同一时刻只允许一条线程对其执行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后只有执行相同次数的unlock操作，变量才会被解锁。 </li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。</li>
<li>如果以个变量实现没有被lock操作锁定，则不允许对它执行unlock操作，也不允许unlock一个被其他线程锁定的变量。 </li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存（执行store和write操作）。  </li>
</ul>
<p><strong>volatile型变量的特殊规则</strong><br>Java 内存模型对volatile专门定义了一写特殊的访问规则，当一个变量被定义成volatile之后，他将具备两种特性：  </p>
<ul>
<li>保证此变量对所有线程的可见性。这里不具体解释了。需要注意，volatile变量的写操作除了对它本身读操作可见外，volatile写操作之前的所有共享变量均对volatile读操作之后可见，另外注意其适用场景。  </li>
<li>禁止指令重排序优化。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获得正确的结果，而不能保证变量赋值操作的顺序与程序中的执行顺序一致，在单线程中，我们是无法感知这一点的。</li>
<li>补充：Java语言规范规定了JVM线程内部维持顺序化语义，也就是说只要程序的最终结果等同于它在严格顺序化环境下的结果，那么指令的执行顺序就可能与代码的顺序不一致，这个过程通过叫做指令的重排序。指令重排序存在的意义在于：JVM 能够根据处理器的特性（CPU 的多级缓存系统、多核处理器等）适当的重新排序机器指令，使机器指令更符合 CPU 的执行特点，最大限度的发挥机器的性能。在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。  </li>
</ul>
<p><strong>final域</strong><br>final类型的域是不能被修改的，除了这一点外，在Java内存模型中，final域还有着特殊的语义，final域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无需同步。具体而言，就是被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看到final字段的值，而且其外，外部可见状态永远也不会改变。它所带来的安全性是最简单最纯粹的。  </p>
<p><strong>long和double型变量的特殊规则</strong><br>Java 内存模型要求lock、unlock、read、load、assign、use、store和write这8个操作都具有原子性，但是对于64位数据类型long和double，在模型中特别定义了一条宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行。这样，如果有多个线程共享一个未被声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读到一个既非原值，也非其他线程修改的代表了“半个变量”的数值。不过这种读取到“半个变量”的情况非常罕见，因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。目前各个平台下的商用虚拟机几乎都选择把 64 位数据的读写操作作为原子操作来对待，因此在编码时，不需要将 long 和 double 变量专门声明为 volatile。</p>
]]></content>
      
        
        <tags>
            
            <tag> Java 并发编程实战 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一部分总结]]></title>
      <url>http://kxh.ink/2017/01/06/summary-one/</url>
      <content type="html"><![CDATA[<h2 id="并发主要概念和规则"><a href="#并发主要概念和规则" class="headerlink" title="并发主要概念和规则"></a>并发主要概念和规则</h2><ul>
<li>可变状态至关重要的<br>&emsp;&emsp;所有的并发问题都可以归结为如何协调对并发状态的访问。可变状态越少，就越容易确保线程安全性。</li>
<li>尽量将域声明为final类型，除非需要它们是可变的。</li>
<li>不可变对象一定是线程安全的。<br>&emsp;&emsp;不可变对象能极大的降低并发编程的复杂性。它们更为简单且安全，可以任意共享而无须使用加锁或者保护复制等机制。<a id="more"></a></li>
<li>封装有助于管理复杂性。<br>&emsp;&emsp;在编写线程安全的程序时，虽然可以将所有数据都保存在全局变量中，但为什么要这样做？将数据封装在对象中，更易于维护不变性条件：将同步机制封装在对象中，更易于遵循同步策略。</li>
<li>用锁来保护每个可变变量。</li>
<li>当保护同一个不变性条件中的所有变量时，要使用同一个锁。</li>
<li>在执行复合操作期间，要持有锁。</li>
<li>如果从多线程中访问同一个可变变量时没有同步机制，那么程序会出现问题。</li>
<li>不要故作聪明地推断出不需要使用同步。</li>
<li>在设计过程中考虑线程安全，或者在文档中明确的指出它不是线程安全的。  </li>
<li>将同步策略文档化。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Java 并发编程实战 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[同步工具类]]></title>
      <url>http://kxh.ink/2017/01/05/synchronization-tool-class/</url>
      <content type="html"><![CDATA[<h2 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h2><p>&emsp;&emsp;闭锁可以延迟线程的进度直到其达到终止状态[CPJ 3.4.2]。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程能通过，当到达结束状态时，这扇门会打开并允许所有线程通过。当闭锁到达结束状态后，将不会再改变状态。因此这扇门将永远保持打开状态。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行，例如:</p>
<ul>
<li>确保某个计算在其需要的所有资源都被初始化之后才继续执行。二元闭锁（包括两个状态）可以用来表示“资源R已经被初始化”，而所有需要R的操作都必须先在这个闭锁上等待。</li>
<li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动。每个服务都有一个相关的二元闭锁。当启动服务S时，将首先在S依赖的其他服务的闭锁上等待，在所有依赖的服务都启动后会释放闭锁S，这样其依赖S的服务才能继续执行。</li>
<li>等待直到某个操作的所有参与者（例如，在多玩家游戏中的所有玩家）都就绪再继续执行。在这种情况中，当所有玩家都准备就绪时，闭锁将到达结束状态。  <a id="more"></a>
&emsp;&emsp;CountDownLatch是一种灵活的闭锁实现，可以在上述各种情况中使用，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么await会一直阻塞到计数器为零，或者等待中的线程中断，或者等待超时。 <h3 id="代码例子："><a href="#代码例子：" class="headerlink" title="代码例子："></a>代码例子：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2017/1/5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTakes</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        startGate.await();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            task.run();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            endGate.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        startGate.countDown();</span><br><span class="line">        endGate.await();</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestHarness testHarness = <span class="keyword">new</span> TestHarness();</span><br><span class="line">        <span class="keyword">long</span> nanoTime = testHarness.timeTakes(<span class="number">10</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"Task is over!!!"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(nanoTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>&emsp;&emsp;FutureTask也可以做闭锁。FutureTask表示的计算是通过Callable来实现的，相当于一种可生成结果的Runnable，并且可以处于以下3种状态：等待运行（Waiting to run），正在运行（Running）和运行完成（Completed）。“执行完成”表示计算的所有可能结束方式，包括正常结束、由于取消而结束和由于异常而结束等。当FutureTask 进入完成状态后，它会永远停在这个状态上。<br>&emsp;&emsp;FutureTask.get的行为取决于任务的状态。如果任务已经完成，那么get会立即返回结果，否则get将阻塞直到任务进入完成状态，然后返回结果或者抛出异常。FutureTask将计算结果从执行计算的线程传递到获取这个结果的线程，而FutureTask的规范确保了这种传递过程能实现结果的安全发布。  </p>
<h3 id="代码例子：-1"><a href="#代码例子：-1" class="headerlink" title="代码例子："></a>代码例子：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2017/1/4.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Preloader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Task is over"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> futureTask.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        Preloader preloader = <span class="keyword">new</span> Preloader();</span><br><span class="line">        preloader.start();</span><br><span class="line">        System.out.println(preloader.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在Preloader中，当get方法抛出ExecutionException时，可能是以下三种情况之一：Callable抛出的受检查异常，RuntimeException，以及Error。我们必须对每种情况单独处理。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>&emsp;&emsp;计数信号量（Counting Semaphore）用来控制同时访问的某个特定资源的操作数量，或者同时执行某个指定操作的数量[CPJ 3.4.1]。计算信号量还可以用来实现某种资源池，或者对容器施加边界。<br>&emsp;&emsp;Semaphore中管理着一组虚拟许可（permit），许可的初始量可通过构造函数来指定。在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用以后释放许可。如果没有许可，那么acquire将阻塞直到有许可（或者直到被中断或者操作超时）。release方法将返回一个许可给信号量。计算信号量的一种简化形式是二值信号量，即初始化值为1的Semaphore。二值信号量可以用做互斥体（mutex），并具备不可重入的加锁语义：谁拥有这个唯一的许可，谁就拥有了互斥锁。  </p>
<h3 id="代码例子：-2"><a href="#代码例子：-2" class="headerlink" title="代码例子："></a>代码例子：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2017/1/5.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程池</span></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 只能5个线程同时访问</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 模拟20个客户端访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">20</span>; index++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> NO = index;</span><br><span class="line">            Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取许可</span></span><br><span class="line">                        semp.acquire();</span><br><span class="line">                        System.out.println(<span class="string">"Accessing: "</span> + NO);</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                        <span class="comment">// 访问完后，释放</span></span><br><span class="line">                        semp.release();</span><br><span class="line">                        System.out.println(<span class="string">"-----------------"</span> + semp.availablePermits());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(run);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出线程池</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>&emsp;&emsp;栅栏（Barrier）类似于闭锁，它能阻塞一组线程直到某个事件发生[CPJ 4.4.3]。闭锁是一次性对象，一旦进入最终状态，就不能被重置了。栅栏与闭锁的关键区别在于，所有线程必须同时达到栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。栅栏用于实现一些协议，例如几个家庭决定在某个地方集合：“所有人6：00在麦当劳碰头，到了以后要等其他人，之后再讨论下一步要做的事情。”<br>&emsp;&emsp;CyclicBarrer可以使一定数量的参与方反复地在栅栏位置汇集，它在并行迭代算法中非常有用：这种算法通常将一个问题拆分一些列互相独立的子问题。如果所有线程都达到了栅栏位置，那么栅栏将打开，为此所有线程都被释放，而栅栏将被重置以便下次使用。如果对await的调用超时，或者await阻塞的线程被中断，那么栅栏就认为是打破了，所有阻塞的await调用都将终止并抛出BrokenBarrerException。如果成功通过栅栏，那么await将为每个线程返回一个唯一的到达索引号，我们可以利用这些索引来“选举”产生一个领导线程，并在下一次迭代中由该领导线程执行一些特殊的工作。CyclicBarrer还可以使你将一个栅栏操作传递给构造函数,这是Runnable，当成功通过栅栏时会（在一个子任务线程中）执行它，但在阻塞线程被释放之前是不能被执行的。<br>&emsp;&emsp;在模拟程序中通常需要使用栅栏，例如某个步骤中的计算可以并行执行，但必须等到该步骤中的所有计算都执行完成才能进入下一个步骤。  </p>
<h3 id="代码例子：-3"><a href="#代码例子：-3" class="headerlink" title="代码例子："></a>代码例子：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2017/1/6.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCyclicBarrier</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        CyclicBarrier barrier  = new CyclicBarrier(N,new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void run() &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println("当前线程"+Thread.currentThread().getName());</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">25000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"CyclicBarrier重用"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"正在写入数据..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);      <span class="comment">//以睡眠来模拟写入数据操作</span></span><br><span class="line">                System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() + <span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line"></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"所有线程写入完毕，继续处理其他任务..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> Java 并发编程实战 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对象的共享]]></title>
      <url>http://kxh.ink/2016/12/22/DuiXiangGongXiang/</url>
      <content type="html"><![CDATA[<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>当读操作和写操作在不同线程的时候，读到可能是旧的值。为了确保多线程之间对内存的写入操作的可见性，必须使用同步机制。<br>当线程在没有同步的情况下读取变量时，可能会得到一个失效的值，但至少这个值是由之前某个线程设置的值，而不是随机值。这种安全性保证也被称为最低安全性。<br>最低安全性适用于大多数变量，但是存在一个例外：非volatile类型的64位数值变量double和long。Java内存模型要求，变量的读写操作都必须原子操作，但是对于非volatile类型的long和double变量，JVM允许将64位的读写操作分解为两个32位的操作。当读取一个非volatile类型的long变量时，如果对该变量的读写操作在不同线程执行，那么很可能会一个线程刚写入高32位，就被另一个线程读到，那么读线程就读到一个新的高32和旧低32位的值。<br>加锁的意义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程能看到共享变量的最新值，所有执行读写操作的线程都必须在同一个锁上同步。<br><a id="more"></a></p>
]]></content>
      
        
        <tags>
            
            <tag> Java 并发编程实战 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并发简史]]></title>
      <url>http://kxh.ink/2016/12/06/BingFaJianShi/</url>
      <content type="html"><![CDATA[<ul>
<li><strong>资源利用率:</strong> 在一些情况下，程序必须等待某个外部操作执行完成，例如输入操作或者输出操作等，而在等待时程序无法执行其他任何操作。因此，如果在等待的同时可以运行另一个程序，那么无疑将提高资源的利用率。</li>
<li><strong>公平性：</strong> 不同的用户和程序对于计算机上的资源有着同等的使用权。一种高效的运行方式是通过粗粒度的时间分片（Tmie Slicing）使这些用户和程序能共享计算机资源，而不是由一个程序从头运行到尾，然后再启动下一个程序。</li>
<li><strong>便利性：</strong> 通常来说，在计算多个任务时，应该编写多个程序，每个程序执行一个任务并在必要的时候互相通信，这比只编写一个程序来计算所有任务更容易实现。</li>
</ul>
<a id="more"></a>
<p><strong>不论什么时候，只要您将修改的变量接下来可能被另一个线程读取，或者您将读取的变量最后是被另一个线程写入的，那么您必须考虑并发问题，并采取合适的同步方式。</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> Java 并发编程实战 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[同步和Java内存模型 (三)可见性]]></title>
      <url>http://kxh.ink/2016/11/15/syn-jmm-visibility/</url>
      <content type="html"><![CDATA[<p>只有在下列情况时，一个线程对字段的修改才能确保对另一个线程可见： </p>
<ul>
<li>一个写线程释放一个锁之后，另一个读线程随后获取了同一个锁。<br>本质上，线程释放锁时会将强制刷新工作内存中的脏数据到主内存中，获取一个锁将强制线程装载（或重新装载）字段的值。锁提供对一个同步方法或块的互斥性执行，线程执行获取锁和释放锁时，所有对字段的访问的内存效果都是已定义的。<br>注意同步的双重含义：锁提供高级同步协议，同时在线程执行同步方法或块时，内存系统（有时通过内存屏障指令）保证值的一致性。这说明，与顺序程序设计相比较，并发程序设计与分布式程序设计更加类似。同步的第二个特性可以视为一种机制：一个线程在运行已同步方法时，它将发送和/或接收其他线程在同步方法中对变量所做的修改。从这一点来说，使用锁和发送消息仅仅是语法不同而已。<a id="more"></a></li>
<li>如果把一个字段声明为volatile型，线程对这个字段写入后，在执行后续的内存访问之前，线程必须刷新这个字段且让这个字段对其他线程可见（即该字段立即刷新）。每次对volatile字段的读访问，都要重新装载字段的值。</li>
<li>一个线程首次访问一个对象的字段，它将读到这个字段的初始值或被某个线程写入后的值。<br>此外，把还未构造完成的对象的引用暴露给某个线程，这是一个错误的做法 (see ?.1.2)。在构造函数内部开始一个新线程也是危险的，特别是这个类可能被子类化时。Thread.start有如下的内存效果：调用start方法的线程释放了锁，随后开始执行的新线程获取了这个锁。如果在子类构造函数执行之前，可运行的超类调用了new Thread(this).start()，当run方法执行时，对象很可能还没有完全初始化。同样，如果你创建且开始一个新线程T，这个线程使用了在执行start之后才创建的一个对象X。你不能确信X的字段值将能对线程T可见。除非你把所有用到X的引用的方法都同步。如果可行的话，你可以在开始T线程之前创建X。</li>
<li>线程终止时，所有写过的变量值都要刷新到主内存中。比如，一个线程使用Thread.join来终止另一个线程，那么第一个线程肯定能看到第二个线程对变量值得修改。  </li>
</ul>
<p>注意，在同一个线程的不同方法之间传递对象的引用，永远也不会出现内存可见性问题。<br>内存模型确保上述操作最终会发生，一个线程对一个特定字段的特定更新，最终将会对其他线程可见，但这个“最终”可能是很长一段时间。线程之间没有同步时，很难保证对字段的值能在多线程之间保持一致（指写线程对字段的写入立即能对读线程可见）。特别是，如果字段不是volatile或没有通过同步来访问这个字段，在一个循环中等待其他线程对这个字段的写入，这种情况总是错误的(see ?.2.6)。</p>
<p>在缺乏同步的情况下，模型还允许不一致的可见性。比如，得到一个对象的一个字段的最新值，同时得到这个对象的其他字段的过期的值。同样，可能读到一个引用变量的最新值，但读取到这个引用变量引用的对象的字段的过期值。<br>不管怎样，线程之间的可见性并不总是失效（指线程即使没有使用同步，仍然有可能读取到字段的最新值），内存模型仅仅是允许这种失效发生而已。因此，即使多个线程之间没有使用同步，也不保证一定会发生内存可见性问题（指线程读取到过期的值），java内存模型仅仅是允许内存可见性问题发生而已。在很多当前的JVM实现和java执行平台中，甚至是在那些使用多处理器的JVM和平台中，也很少出现内存可见性问题。共享同一个CPU的多个线程使用公共的缓存，缺少强大的编译器优化，以及存在强缓存一致性的硬件，这些都会使线程更新后的值能够立即在多线程之间传递。这使得测试基于内存可见性的错误是不切实际的，因为这样的错误极难发生。或者这种错误仅仅在某个你没有使用过的平台上发生，或仅在未来的某个平台上发生。这些类似的解释对于多线程之间的内存可见性问题来说非常普遍。没有同步的并发程序会出现很多问题，包括内存一致性问题。  </p>
<blockquote>
<p>原文：<a href="http://gee.cs.oswego.edu/dl/cpj/jmm.html" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpj/jmm.html</a> 第三章<br>作者：Doug Lea 译者：程晓明 校对：方腾飞 </p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[同步和Java内存模型 (二)原子性]]></title>
      <url>http://kxh.ink/2016/11/15/syn-jmm-atomicity/</url>
      <content type="html"><![CDATA[<p>除了long型字段和double型字段外，java内存模型确保访问任意类型字段所对应的内存单元都是原子的。这包括引用其它对象的引用类型的字段。此外，volatile long 和volatile double也具有原子性 。（虽然java内存模型不保证non-volatile long 和 non-volatile double的原子性，当然它们在某些场合也具有原子性。）（译注：non-volatile long在64位JVM，OS，CPU下具有原子性）<br><a id="more"></a><br>当在一个表达式中使用一个non-long或者non-double型字段时，原子性可以确保你将获得这个字段的初始值或者某个线程对这个字段写入之后的值；但不会是两个或更多线程在同一时间对这个字段写入之后产生混乱的结果值（即原子性可以确保，获取到的结果值所对应的所有bit位，全部都是由单个线程写入的）。但是，如下面（译注：指可见性章节）将要看到的，原子性不能确保你获得的是任意线程写入之后的最新值。 因此，原子性保证通常对并发程序设计的影响很小。  </p>
<blockquote>
<p>原文：<a href="http://gee.cs.oswego.edu/dl/cpj/jmm.html" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpj/jmm.html</a> 第二章<br>作者：Doug Lea 译者：程晓明  校对：方腾飞  </p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[同步与Java内存模型(一)序言]]></title>
      <url>http://kxh.ink/2016/11/15/syn-jmm-pre/</url>
      <content type="html"><![CDATA[<p>先来看如下这个简单的Java类，该类中并没有使用任何的同步。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SetCheck</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            b = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((b == <span class="number">0</span>) ||</span><br><span class="line">                    (b == -<span class="number">1</span> &amp;&amp; a == <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>如果是在一个串行执行的语言中，执行SetCheck类中的check方法永远不会返回false，即使编译器，运行时和计算机硬件并没有按照你所期望的逻辑来处理这段程序，该方法依然不会返回false。在程序执行过程中，下面这些你所不能预料的行为都是可能发生的：</p>
<ul>
<li>编译器可能会进行指令重排序，所以b变量的赋值操作可能先于a变量。如果是一个内联方法，编译器可能更甚一步将该方法的指令与其他语句进行重排序。</li>
<li>处理器可能会对语句所对应的机器指令进行重排序之后再执行，甚至并发地去执行。</li>
<li>内存系统（由高速缓存控制单元组成）可能会对变量所对应的内存单元的写操作指令进行重排序。重排之后的写操作可能会对其他的计算/内存操作造成覆盖。</li>
<li>编译器，处理器以及内存系统可能会让两条语句的机器指令交错。比如在32位机器上，b变量的高位字节先被写入，然后是a变量，紧接着才会是b变量的低位字节。</li>
<li>编译器，处理器以及内存系统可能会导致代表两个变量的内存单元在（如果有的话）连续的check调用（如果有的话）之后的某个时刻才更新，而以这种方式保存相应的值（如在CPU寄存器中）仍会得到预期的结果（check永远不会返回false）。  </li>
</ul>
<p>在串行执行的语言中，只要程序执行遵循类似串行的语义，如上几种行为就不会有任何的影响。在一段简单的代码块中，串行执行程序不会依赖于代码的内部执行细节，因此如上的几种行为可以随意控制代码。这样就为编译器和计算机硬件提供了基本的灵活性。基于此，在过去的数十年内很多技术（CPU的流水线操作，多级缓存，读写平衡，寄存器分配等等）应运而生，为计算机处理速度的大幅提升奠定了基础。这些操作的类似串行执行的特性可以让开发人员无须知道其内部发生了什么。对于开发人员来说，如果不创建自己的线程，那么这些行为也不会对其产生任何的影响。</p>
<p>然而这些情况在并发编程中就完全不一样了，上面的代码在并发过程中，当一个线程调用check方法的时候完全有可能另一个线程正在执行set方法，这种情况下check方法就会将上面提到的优化操作过程暴露出来。如果上述任意一个操作发生，那么check方法就有可能返回false。例如，check方法读取long类型的变量b的时候可能得到的既不是0也不是-1.而是一个被写入一半的值。另一种情况，set方法中的语句的乱序执行有可能导致check方法读取变量b的值的时候是-1，然而读取变量a时却依然是0。</p>
<p>换句话说，不仅是并发执行会导致问题，而且在一些优化操作（比如指令重排序）进行之后也会导致代码执行结果和源代码中的逻辑有所出入。由于编译器和运行时技术的日趋成熟以及多处理器的逐渐普及，这种现象就变得越来越普遍。对于那些一直从事串行编程背景的开发人员（其实，基本上所有的程序员）来说，这可能会导致令人诧异的结果，而这些结果可能从没在串行编程中出现过。这可能就是那些微妙难解的并发编程错误的根本源头吧。</p>
<p>在绝大部分的情况下，有一个很简单易行的方法来避免那些在复杂的并发程序中因代码执行优化导致的问题：使用同步。例如，如果SetCheck类中所有的方法都被声明为synchronized,那么你就可以确保那么内部处理细节都不会影响代码预期的结果了。</p>
<p>但是在有些情况下你却不能或者不想去使用同步，抑或着你需要推断别人未使用同步的代码。在这些情况下你只能依赖Java内存模型所阐述的结果语义所提供的最小保证。Java内存模型允许上面提到的所有操作，但是限制了它们在执行语义上潜在的结果，此外还提出了一些技术让程序员可以用来控制这些语义的某些方面。</p>
<p>Java内存模型是Java语言规范的一部分，主要在JLS的第17章节介绍。这里，我们只是讨论一些基本的动机，属性以及模型的程序一致性。这里对JLS第一版中所缺少的部分进行了澄清。</p>
<p>我们假设Java内存模型可以被看作在1.2.4中描述的那种标准的SMP机器的理想化模型。</p>
<p><img src="70421f3c-de06-4652-91df-3b357e15824c.gif" alt=""></p>
<p>在这个模型中，<strong>每一个线程都可以被看作为运行在不同的CPU上，然而即使是在多处理器上，这种情况也是很罕见的。</strong> 但是实际上，通过模型所具备的某些特性，这种CPU和线程单一映射能够通过一些合理的方法去实现。例如，因为CPU的寄存器不能被另一个CPU直接访问，这种模型必须考虑到某个线程无法得知被另一个线程操作变量的值的情况。这种情况不仅仅存在于多处理器环境上，在单核CPU环境里，因为编译器和处理器的不可预测的行为也可能导致同样的情况。 </p>
<p>Java内存模型没有具体讲述前面讨论的执行策略是由编译器，CPU，缓存控制器还是其它机制促成的。甚至没有用开发人员所熟悉的类，对象及方法来讨论。取而代之，Java内存模型中仅仅定义了线程和内存之间那种抽象的关系。众所周知，每个线程都拥有自己的工作存储单元（缓存和寄存器的抽象）来存储线程当前使用的变量的值。Java内存模型仅仅保证了代码指令与变量操作的有序性，大多数规则都只是指出什么时候变量值应该在内存和线程工作内存之间传输。这些规则主要是为了解决如下三个相互牵连的问题：</p>
<ul>
<li><strong>原子性</strong>：哪些指令必须是不可分割的。在Java内存模型中，这些规则需声明仅适用于-—实例变量和静态变量，也包括数组元素，但不包括方法中的局部变量-—的内存单元的简单读写操作。</li>
<li><strong>可见性</strong>：在哪些情况下，一个线程执行的结果对另一个线程是可见的。这里需要关心的结果有，写入的字段以及读取这个字段所看到的值。</li>
<li><strong>有序性</strong>：在什么情况下，某个线程的操作结果对其它线程来看是无序的。最主要的乱序执行问题主要表现在读写操作和赋值语句的相互执行顺序上。</li>
</ul>
<p>当正确的使用了同步，上面属性都会具有一个简单的特性：一个同步方法或者代码块中所做的修改对于使用了同一个锁的同步方法或代码块都具有原子性和可见性。同步方法或代码块之间的执行过程都会和代码指定的执行顺序保持一致。即使代码块内部指令也许是乱序执行的，也不会对使用了同步的其它线程造成任何影响。</p>
<p>当没有使用同步或者使用的不一致的时候，情况就会变得复杂。Java内存模型所提供的保障要比大多数开发人员所期望的弱，也远不及目前业界所实现的任意一款Java虚拟机。这样，开发人员就必须负起额外的义务去保证对象的一致性关系：对象间若有能被多个线程看到的某种恒定关系，所有依赖这种关系的线程就必须一直维持这种关系，而不仅仅由执行状态修改的线程来维持。  </p>
<blockquote>
<p>原文：<a href="http://gee.cs.oswego.edu/dl/cpj/jmm.html" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpj/jmm.html</a><br>作者：Doug Lea 译者：萧欢  校对：丁一，方腾飞  </p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git CentOS 源码安装]]></title>
      <url>http://kxh.ink/2016/11/02/Git-CentOS-Install/</url>
      <content type="html"><![CDATA[<h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc</span><br><span class="line">yum install curl</span><br><span class="line">yum install curl-devel</span><br><span class="line">yum install zlib-devel</span><br><span class="line">yum install openssl-devel</span><br><span class="line">yum install perl</span><br><span class="line">yum install cpio</span><br><span class="line">yum install expat-devel</span><br><span class="line">yum install gettext-devel</span><br><span class="line">yum install libcurl-devel</span><br><span class="line">yum install autoconf</span><br><span class="line">yum install perl-ExtUtils-Embed</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="下载最新的git包"><a href="#下载最新的git包" class="headerlink" title="下载最新的git包"></a>下载最新的git包</h2><p>在 <a href="https://github.com/git/git/releases" target="_blank" rel="noopener">https://github.com/git/git/releases</a> 找到你需要的源码包,我现在最新的是2.10.2版本<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/git/git/archive/v2.10.2.tar.gz</span><br><span class="line">tar xzvf v2.10.2.tar.gz</span><br><span class="line">cd git-2.10.2</span><br><span class="line">autoconf</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>
<h2 id="收工"><a href="#收工" class="headerlink" title="收工"></a>收工</h2>]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从ACID到CAP到BASE]]></title>
      <url>http://kxh.ink/2016/10/27/ACID-CAP-BASE/</url>
      <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>本文主要讲述分布式系统开发的一些相关理论基础。</p>
<h1 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h1><p>事务的四个特征：</p>
<h2 id="Atomic-原子性-A"><a href="#Atomic-原子性-A" class="headerlink" title="Atomic 原子性(A)"></a>Atomic 原子性(A)</h2><p>事务必须是一个原子的操作序列单元，事务中包含的各项操作在一次执行过程中，要么全部成功，要么全部不执行，任何一项失败，整个事务回滚，只有全部执行成功，整个事务才算成功。</p>
<h2 id="Consistency-一致性-C"><a href="#Consistency-一致性-C" class="headerlink" title="Consistency 一致性(C)"></a>Consistency 一致性(C)</h2><p>事务的执行不能破坏数据库数据的完整性和一致性，事务在执行之前和之后数据库都必须处于一致性状态。</p>
<h2 id="Isolation-隔离性-I"><a href="#Isolation-隔离性-I" class="headerlink" title="Isolation 隔离性(I)"></a>Isolation 隔离性(I)</h2><p>在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰，即不同的事务并发操纵相同的数据时，每个事务都有各自完整的数据空间，即以个事务内部的操作及使用数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。  </p>
<a id="more"></a>
<h3 id="SQL中的4个事务隔离级别："><a href="#SQL中的4个事务隔离级别：" class="headerlink" title="SQL中的4个事务隔离级别："></a>SQL中的4个事务隔离级别：</h3><h4 id="读未提交-READ-UNCOMMITTED"><a href="#读未提交-READ-UNCOMMITTED" class="headerlink" title="读未提交(READ UNCOMMITTED)"></a>读未提交(READ UNCOMMITTED)</h4><blockquote>
<p>允许脏读。如果以个事务正在处理某一条数据，并对其进行了更新，但同时尚未完成事务，因此事务没提交，与此同时，运行另一个事务也能够访问该数据。例如事务A将变量n从0累加到10才提交事务，此时事务B可能读到n变量从0到10之间的所有值。</p>
</blockquote>
<h4 id="读已提交-READ-COMMITTED"><a href="#读已提交-READ-COMMITTED" class="headerlink" title="读已提交(READ COMMITTED)"></a>读已提交(READ COMMITTED)</h4><blockquote>
<p>允许不可重复读。只允许读到已经提交的数据，即事务A在将n从0累计加到10的过程中，事务B无法看到n的中间值，之中只能看到10.同时有事务C进行从10到20的累加，此时B在同一个事务内再次读时，读到的20.</p>
</blockquote>
<h4 id="可重复读-REPEATABLE-READ"><a href="#可重复读-REPEATABLE-READ" class="headerlink" title="可重复读(REPEATABLE READ)"></a>可重复读(REPEATABLE READ)</h4><blockquote>
<p>允许幻读。保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻一致的，禁止脏读、不可重复读。幻读即同样的事务操作，在前后两个时间段执行对同一个数据项的读取，可能出现不一致的结果。保证B在同一事务内，多次读取n的值，读到的都是初始值0.幻读，就是不同事务，读到的n的数据有可能是0，可能是10，可能是20</p>
</blockquote>
<h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><blockquote>
<p>最严格的事务，要求所有事务被串行执行，不能并发执行  </p>
</blockquote>
<p>如果不对事务进行并发控制，我们看看数据库并发操作是会有哪些异常情形</p>
<ul>
<li>一类丢失更新：两个事务读同一数据，一个修改字段1，一个修改字段2，后提交的恢复了先提交修改的字段。</li>
<li>二类丢失更新：两个事务读取同一数据，都修改同一字段，后提交的覆盖了先提交的修改。</li>
<li>脏读：读到了未提交的值，万一事务回滚，则产生脏读。</li>
<li>不可重复读：两个查询之间，被另外一个事务修改了数据内容，产生内容的不一致</li>
<li>幻读：两个查询之间，被另外一个事务插入或删除了记录，产生结果不一致。</li>
</ul>
<h2 id="Durability-持久性-D"><a href="#Durability-持久性-D" class="headerlink" title="Durability 持久性(D)"></a>Durability 持久性(D)</h2><p>一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。即使发生系统崩溃或者宕机，只要数据库能够重新启动，那么一定能够将其回复到事务成功结束的状态。</p>
<h1 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h1><p>一个分布式系统不可能同时满足一致性Consistency、可用性Availability、分区容错性Partition tolerance 这三个基本需求，最多只能同时满足其中两项。</p>
<h2 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性 Consistency"></a>一致性 Consistency</h2><p>分布式环境中，一致性是指多个副本之间能否保持一致性的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。</p>
<h2 id="可用性-Availability"><a href="#可用性-Availability" class="headerlink" title="可用性 Availability"></a>可用性 Availability</h2><p>系统提供的服务必须一直处于可用状态，对于用户的每个操作请求总是能够在有限的时间内返回结果。</p>
<ul>
<li>有限时间内对于用户的一个操作请求，系统必须能够在指定的时间(响应时间)内返回对应的处理结果，如果超过了这个时间范围，那么系统被认为是不可用的。即这个响应时间必须在一个合理值内，不让用户感到失望。</li>
<li>返回正常结果要求系统完成对用户请求处理后，返回一个正常的响应结果。正常的响应结果通常能够明确地反映出对请求的处理结果，即成功或失败，而不是一个让用户感到困惑的返回结果。比如返回一个系统错误如OutOfMemory，则认为系统是不可用的。</li>
</ul>
<h2 id="分区容错性-Partition-tolerance"><a href="#分区容错性-Partition-tolerance" class="headerlink" title="分区容错性 Partition tolerance"></a>分区容错性 Partition tolerance</h2><p>即分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p>
<p>网络分区，是指分布式系统中，不同的节点分布在不同的子网络（机房/异地网络）中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状态，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干孤立的区域。组成一个分布式系统的每个节点的加入与退出都可以看做是一个特殊的网络分区。</p>
<h1 id="CAP的应用"><a href="#CAP的应用" class="headerlink" title="CAP的应用"></a>CAP的应用</h1><h2 id="放弃-分区容错性-P"><a href="#放弃-分区容错性-P" class="headerlink" title="放弃-分区容错性(P)"></a>放弃-分区容错性(P)</h2><p>放弃分区容错性的话，则放弃分布式，放弃了系统的可扩展性</p>
<h2 id="放弃-可用性-A"><a href="#放弃-可用性-A" class="headerlink" title="放弃-可用性(A)"></a>放弃-可用性(A)</h2><p>放弃可用性的话，则在遇到网络分区或其他故障时，受影响的服务需要等待一定的时间，再此期间无法对外提供政策的服务，即不可用</p>
<h2 id="放弃-一致性-C"><a href="#放弃-一致性-C" class="headerlink" title="放弃-一致性(C)"></a>放弃-一致性(C)</h2><p>放弃一致性的话（这里指强一致），则系统无法保证数据保持实时的一致性，在数据达到最终一致性时，有个时间窗口，在时间窗口内，数据是不一致的。</p>
<p>对于分布式系统来说，P是不能放弃的，因此架构师通常是在可用性和一致性之间权衡。</p>
<h1 id="BASE定理"><a href="#BASE定理" class="headerlink" title="BASE定理"></a>BASE定理</h1><p>Basically Available（基本可用）、Soft state（软状态）、Eventually consistent（最终一致性），基于CAP定理演化而来，核心思想是即时无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<h2 id="Basically-Available-基本可用"><a href="#Basically-Available-基本可用" class="headerlink" title="Basically Available(基本可用)"></a>Basically Available(基本可用)</h2><blockquote>
<p>基本可用是指分布式系统在出现不可预知的故障的时候，允许损失部分可用性，但不等于系统不可用。</p>
</blockquote>
<h3 id="响应时间上的损失"><a href="#响应时间上的损失" class="headerlink" title="响应时间上的损失"></a>响应时间上的损失</h3><blockquote>
<p>当出现故障时，响应时间增加</p>
</blockquote>
<h3 id="功能上损失"><a href="#功能上损失" class="headerlink" title="功能上损失"></a>功能上损失</h3><blockquote>
<p>当流量高峰期时，屏蔽一些功能的使用以保证系统稳定性(服务降级)</p>
</blockquote>
<h2 id="Soft-state-软状态"><a href="#Soft-state-软状态" class="headerlink" title="Soft state(软状态)"></a>Soft state(软状态)</h2><p>与硬状态相对，即是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h2 id="Eventually-consistent-最终一致性"><a href="#Eventually-consistent-最终一致性" class="headerlink" title="Eventually consistent(最终一致性)"></a>Eventually consistent(最终一致性)</h2><p>强调系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。其本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<h3 id="最终一致性可分为如下几种："><a href="#最终一致性可分为如下几种：" class="headerlink" title="最终一致性可分为如下几种："></a>最终一致性可分为如下几种：</h3><ul>
<li><strong>因果一致性(Causal consistency)</strong>即进程A在更新完数据后通知进程B，那么之后进程B对该项数据的范围都是进程A更新后的最新值。</li>
<li><strong>读己之所写(Read your writes)</strong>进程A更新一项数据后，它自己总是能访问到自己更新过的最新值。</li>
<li><strong>单调读一致性(Monotonic read consistency)</strong>如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</li>
<li><strong>单调写一致性(Monotoic write consistency)</strong>一个系统需要保证来自同一个进程的写操作被顺序执行。</li>
</ul>
<p>BASE定理是提出通过牺牲一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。  </p>
<blockquote>
<p>转载 <a href="https://segmentfault.com/a/1190000004468442" target="_blank" rel="noopener">从ACID到CAP到BASE</a></p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[分布式事务]]></title>
      <url>http://kxh.ink/2016/10/27/distributed-tx-evolution/</url>
      <content type="html"><![CDATA[<h1 id="分布式事务背景"><a href="#分布式事务背景" class="headerlink" title="分布式事务背景"></a>分布式事务背景</h1><p>现在分布式系统一般由多个独立的子系统组成，多个子系统通过进程间通信（<a href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank" rel="noopener">RPC</a>）互相协作配合完成各个功能。有很多用例会跨多个子系统才能完成，比较典型的是电子商务网站的下单支付流程，至少会涉及交易系统和支付系统，而且这个过程中会涉及到事务的概念，即保证交易系统和支付系统的数据一致性。通常我们谈及的事务是指单机资源的<a href="http://baike.baidu.com/subview/600227/5926023.htm" target="_blank" rel="noopener">ACID</a>属性，所以此处我们称这种跨系统的事务为分布式事务。<br><a id="more"></a></p>
<h1 id="分布式事务实现方式"><a href="#分布式事务实现方式" class="headerlink" title="分布式事务实现方式"></a>分布式事务实现方式</h1><p>对于分布式事务，通常采用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4" target="_blank" rel="noopener">2PC</a>（两阶段提交）以及相应的变种3PC来实现（因为2PC有致命的问题，<a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4" target="_blank" rel="noopener">3PC</a>通过拆分2PC的第一阶段避免了极端情况下的问题，详情请参考coolshell），使用两阶段提交来协调所有参与到分布式事务中的各个事务资源，Java中也提供了JTA规范来标准化分布式事务接口，目前Mysql和PostgreSQL也都默认实现XA接口，从而支持分布式事务了。而且对于开发人员来说，使用分布式事务和单机事务并没有太大的差异，最起码从编程模型上来看，也就实现了所谓的“透明”</p>
<h1 id="分布式事务的弊端"><a href="#分布式事务的弊端" class="headerlink" title="分布式事务的弊端"></a>分布式事务的弊端</h1><p>前文也讲到了，因为JTA的标准化，使得分布式事务和单机事务的编程模型看起来很接近，从而实现了“透明”，但是单机事务和分布式事务最大的差异是性能并不“透明”，单机事务的资源都在一台节点上完成变更，不会出现跨进程、跨网络的情况，使得单机事务的性能很好。反观分布式事务，会跨多个进程，跨网络，甚至会跨数据中心，对于跨网络的开销和本地事务操作的对比，可以参考网上的资料。</p>
<p>在其中一个事务执行成功之后并且还未提交之前，会对资源进行锁定，一般是加上X锁，在锁定期间对被锁定的资源访问是受限的，直到通过协调的其他各个事务资源都提交才会释放，由此可见，资源被锁定的时间相比单机事务大大加长了，也就直接导致了系统的TPS降低，单位时间执行的事务数量减少了，系统的吞吐量也会降低，同时意味着支持同样数量的TPS需要加入更多的节点。</p>
<p>不仅如此，由于各个事务资源对应的子系统必须完全执行成功才能完成整个功能，那么意味着整个功能的可用性降低了，假如需要三个子系统来协调完成功能A，每个系统的可用性是99.9%，这样功能A的可用性就是99.9%<em>99.9%</em>99.9%=99.7%，如果有更多的子系统参与进来，后果可想而知，系统可用性会变得不可接受。</p>
<p>另外，根据木桶原理，决定整个协调过程完成时间的是执行最慢的节点，其他节点则只能等待，整个系统都会跟着慢下来。  </p>
<h1 id="强一致性模型的必要性"><a href="#强一致性模型的必要性" class="headerlink" title="强一致性模型的必要性"></a>强一致性模型的必要性</h1><p>既然分布式事务有诸多缺点，那么为什么我们还在使用呢？有没有更好的解决方案来改进或者替换呢？如果我们只是针对分布式事务去优化的话，发现其实能改进的空间很小，毕竟瓶颈在分布式事务模型本身，“我们无法用我们制造问题的思维方式去解决我们的制造的问题”，爱因斯坦如是说。</p>
<p>那我们回到问题的根源：为什么我们需要分布式事务？因为我们需要各个资源数据一致性。对，看起来合情合理，我们需要，而分布式事务恰好解决这个问题，但是分布式事务提供的是强一致性，试问下，我们真的需要强一致性吗？大多数业务场景都能容忍短暂的不一致，只是不同的业务对不一致的时间窗口要求不同罢了，像银行转账业务，中间有几小时几天的不一致窗口，用户是可以理解和容忍的，而像电商支付业务，用户的容忍度可能只是30秒的样子，其实30秒对于系统而言已经很长了，还有搜索引擎的收录等等。</p>
<p>通过这些例子，可以确定我们可以忍受短暂的不一致，即我们不需要强一致性，只需要最终一致性。对要求的进一步降低，是不是意味着可以有更加合理的方案呢？ </p>
<h1 id="单机事务-异步复制"><a href="#单机事务-异步复制" class="headerlink" title="单机事务+异步复制"></a>单机事务+异步复制</h1><p>以订单子系统和支付子系统为例，如下：</p>
<table>
<thead>
<tr>
<th>payment</th>
<th>trade</th>
</tr>
</thead>
<tbody>
<tr>
<td>payment_record</td>
<td>trade_record</td>
</tr>
<tr>
<td>user_account</td>
<td>tx_duplication</td>
</tr>
<tr>
<td>tx_info</td>
<td></td>
</tr>
</tbody>
</table>
<p>如上图，payment是支付系统，trade是订单系统，两个系统对应的数据库是分开的。支付完成之后，支付系统需要通知订单系统状态变更，从而开始接下来的操作。</p>
<p>对于payment要执行的操作可以用伪代码表示如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tx;</span><br><span class="line">count = <span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> amount = amount - $&#123;cash&#125; <span class="keyword">where</span> uid = $&#123;uid&#125; <span class="keyword">and</span> amount &gt;= amount</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">count</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">update</span> payment_record <span class="keyword">set</span> <span class="keyword">status</span> = paid <span class="keyword">where</span> trade_id = $&#123;tradeId&#125;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>对于trade要执行的操作可以用伪代码表示如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tx;</span><br><span class="line">count = <span class="keyword">update</span> trade_record <span class="keyword">set</span> <span class="keyword">status</span> = paid <span class="keyword">where</span> trade_id = $&#123;trade_id&#125; <span class="keyword">and</span> <span class="keyword">status</span> = unpaid</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">count</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">do</span> other things ...</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>但是对于这两段代码如何串起来是个问题，我们增加一个事务表，即图中的tx_info，来记录成功完成的支付事务，那么为了和支付信息一致，需要放入事务中，代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tx;</span><br><span class="line">count = <span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> amount = amount - $&#123;cash&#125; <span class="keyword">where</span> uid = $&#123;uid&#125; <span class="keyword">and</span> amount &gt;= amount</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">count</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">update</span> payment_record <span class="keyword">set</span> <span class="keyword">status</span> = paid <span class="keyword">where</span> trade_id = $&#123;tradeId&#125;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tx_info <span class="keyword">values</span>($&#123;trade_id&#125;,$&#123;amount&#125;...)</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>支付系统边界到此为止，简单吧？那么接下来就是订单系统启动时间程序去轮询访问（直接和间接）tx_info，拉取已经支付成功的订单信息，对每一条信息都执行trade系统的逻辑，伪代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foreach trade_id in tx_info</span><br><span class="line">  <span class="keyword">do</span> trade_tx</span><br><span class="line"><span class="keyword">save</span> tx_info.id <span class="keyword">to</span> <span class="keyword">some</span> <span class="keyword">store</span></span><br></pre></td></tr></table></figure>
<p>事无延迟取决于时间程序轮询间隔，这样我们做到了一致性，最终订单都会在支付之后的最大时间间隔内完成状态迁移。  </p>
<p>等等，我们好像还差点东西，交易系统每次拉取数据的起点以及消费记录是否得记录下来，这样才能不遗漏不重复地执行，所以需要增加一张表用于排重，即上图中的tx_duplication。但是每次对tx_duplication表的插入要在trade_tx的事务中完成，伪代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> tx;</span><br><span class="line">c = <span class="keyword">insert</span> <span class="keyword">ignore</span> tx_duplication <span class="keyword">values</span>($trade_id...)</span><br><span class="line"><span class="keyword">if</span> (c &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">count</span> = <span class="keyword">update</span> trade_record <span class="keyword">set</span> <span class="keyword">status</span> = paid <span class="keyword">where</span> trade_id = $&#123;trade_id&#125; <span class="keyword">and</span> <span class="keyword">status</span> = unpaid</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">count</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">do</span> other things ...</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>另外，tx_duplication表中trade_id表上必须有唯一键，这个算是结合之前的幂等篇来保证trade_tx的操作是幂等的，到此为止，我们已经完全实现了异步复制实现多个单机事务一致性的目标。看起来是个完美的通用方案，不是吗？但是仔细看看也会明白，这个方案也会有自己的问题，比如交易系统要访问支付系统的数据库、系统要多增加几张表等等，我们可以抽取组件实现这些，但是依然隐藏不了那些表。那么是不是有更加优雅的方式来改进呢？答案是肯定的，接下来继续。</p>
<h1 id="带有事务功能的MQ做中间人角色"><a href="#带有事务功能的MQ做中间人角色" class="headerlink" title="带有事务功能的MQ做中间人角色"></a>带有事务功能的MQ做中间人角色</h1><p>其实在上边的方案中，tx_info表所起到的作用就是队列作用，记录一个系统的表更，作为通知给需要感知的系统的事件。而时间程序去拉取只是系统去获取感兴趣事件的一个方式，而对应交易系统的本地事务只是对应消费事件的一个过程。在这样的描述下，这些功能就是一个MQ——消息中间件。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    subgraph trade</span><br><span class="line">    trade_record --- tx_duplication</span><br><span class="line">    end</span><br><span class="line">    subgraph payment</span><br><span class="line">    payment_reaord --- user_accout</span><br><span class="line">    end</span><br><span class="line">    user_accout--&gt;MQ</span><br><span class="line">    tx_duplication--&gt;MQ</span><br></pre></td></tr></table></figure>
<p>这样tx_info表的功能就交给了MQ，消息消费的偏移量也不需要关心了，MQ会搞定的，但是tx_duplication还是必须存在的，因为MQ并不能避免消息的重复投递，这其中的原因有很多，主要是还是分布式的三态造成的，再次不详细描述。</p>
<p>这要求MQ必须支持事务功能，可以达到本地事务和消息发出是一致性的，但是不必是强一致的。通常使用的方式如下的伪代码：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sendPrepare();</span><br><span class="line">isCommit = local_tx()</span><br><span class="line">if (isCommit) sendCommit()</span><br><span class="line">else sendRollback()</span><br></pre></td></tr></table></figure>
<p>在做本地事务之前，先向MQ发送一个prepare消息，然后执行本地事务，本地事务提交成功的话，向MQ发送一个commit消息，否则发送一个rollback消息，取消之前的消息。MQ只会在收到commit确认才会将消息投递出去，所以这样的形式可以保证在一切正常的情况下，本地事务和MQ可以达到一致性。  </p>
<p>但是分布式存在异常情况，网络超时，机器宕机等等，比如当系统执行了local_tx()成功之后，还没来得及将commit消息发送给MQ，或者说发送出去了，网络超时了等等原因，MQ没有收到commit，即commit消息丢失了，那么MQ就不会把prepare消息投递出去。如果这个无法保证的话，那么这个方案是不可行的。针对这种情况，MQ会根据策略去尝试询问（回调）发消息的系统（checkCommit）进行检查该消息是否应该投递出去或者丢弃，得到系统的确认之后，MQ会做投递还是丢弃，这样就完全保证了MQ和发消息的系统的一致性，从而保证了接收消息系统的一致性。  </p>
<p>不过这个方案要求MQ的系统可用性必须非常高，至少要超过使用MQ的系统，这样才能保证依赖他的系统能稳定运行。目前提供这种机制的MQ并不多，个人了解到的有阿里的notify和ons。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>写在最后，对于数据库实现的异步复制方案是参考<a href="http://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">ebay</a>的架构师的一篇论文，详细讲述了实现过程，很经典，可以点链接进去看看。使用MQ的方案是一个比较成熟的方案，而且MQ方案不止带来了这么多好处，带来了异步化、重试机制、系统解耦，还可以在不同访问量的系统之间起到消峰缓冲的作用，可以把系统交互变得更加优雅。  </p>
<blockquote>
<p>转载 <a href="http://yongpoliu.com/distributed-tx-evolution/" target="_blank" rel="noopener">分布式事务演进</a></p>
</blockquote>
<h1 id="2016-10-21-23-07-38-康兴华"><a href="#2016-10-21-23-07-38-康兴华" class="headerlink" title="2016-10-21 23:07:38 康兴华"></a>2016-10-21 23:07:38 康兴华</h1><blockquote>
<p>我们无法用我们制造问题的思维方式去解决我们的制造的问题。–爱因斯坦</p>
</blockquote>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[幂等性]]></title>
      <url>http://kxh.ink/2016/10/27/Idempotent/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在稍微有点规模的网站和大型应用都不再是单机模式，而是分布式应用，基于多机器的集群构建的应用，这服务能力就可以基本实现横向扩展（scale out），不会像单机模式下的纵向扩容（scale up)会受到单机服务能力的上限限制。另外随着”<a href="http://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">微服务</a>“概念的火爆，很多应用在构建之处就已经走上了分布式的道路。所有就目前行业的发展来，基于分布式应用会越来越普遍，甚至变为常态。加上”<a href="https://www.docker.com/" target="_blank" rel="noopener">docker</a>“的这些容器技术的出现，应用分布式工具也会越来越成熟。<br><a id="more"></a></p>
<h1 id="分布式的复杂性"><a href="#分布式的复杂性" class="headerlink" title="分布式的复杂性"></a>分布式的复杂性</h1><p>众所周知，构建分布式应用所面临的复杂性远远超过集中式的单一应用，导致复杂性的因素有很多，在此只提一点：<strong>网络不可靠</strong>。在单一进程内部，对一个函数的调用，结果只有种–成功和失败，失败的情况下，调用者可以决定做一些事情弥补。但是在跨进程调用中，对一个远程（也可以在同一节点上）进程上运行的函数调用除了会得到成功和失败，还会有第三种情况–超时，这个现象被称为分布式三状态。这个是困扰分布式应用构建的最核心因素之一，很多分布式应用的复杂度之所以这么高也是因为三状态中的超时引起的。 </p>
<p>简单看看超时给我们带来困扰，进程A调用进程B上的函数f，对于成功和失败的结果，相信和单机下一样，进程A都可以进行很好地处理，因为结果是很明确的。如果进程A调用f之后，在允许的等待最大时间内没有返回结果，就是调用超时了，此时进程A能做什么？其实进程A什么都做不了，因为超时是一个不明确的结果——成功和失败都有可能。详细解释下可能的情况：</p>
<ul>
<li>成功的情况：进程A把数据通过网络传输到进程B上，f执行成功，通 网络返回执行结果给进程A，可是网络不太好，传输失败了，进程A并 未在指定时间内收到结果，认为超时了。</li>
<li>失败的情况：情况和成功的情况差不多，只是f执行失败了，但是结 果依然传输失败，进程A也认为执行超时了。</li>
<li>未执行的情况：进程A的数据发送到进程B所在的节点过程中网络失败 了，或者发送到了进程B所在的机器上，但是进程B没有消费掉在TCP 网络层的数据等等   </li>
</ul>
<p>由此可见，进程A对于超时确实无能为力，有太多的可能存在的情况了。但是分布式协作过程中又必须解决这个问题，不然分布式应用是没意义的，这种情况下，一般会采用让进程A尝试重试——即重复发起之前的调用。但是这样也可能会带来问题，因为超时的那次调用可能已经成功了，再次以同样的参数调用f会不会带来额外的问题？这就引出本文的主角——<strong><a href="http://baike.baidu.com/view/2067025.htm" target="_blank" rel="noopener">幂等性</a></strong></p>
<h1 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h1><p>幂等性本来是一个数学概念，在计算机方面用来表示对同一个过程应用相同的参数多次和应用一次产生的效果是一样，这样的过程即被称为满足幂等性。  </p>
<p>有了这个概念之后，假如之前的f是满足幂等性的，那么是不是意味着进程A在调用f超时之后，可以继续重复调用f多次？这样最起码进程A可以在超时情况下做一些促进事情正向发展的努力。所以这种方式是分布式节点间常用的方式，那么如何保证幂等呢？</p>
<h1 id="如何实现幂等行"><a href="#如何实现幂等行" class="headerlink" title="如何实现幂等行"></a>如何实现幂等行</h1><p>在考虑实现幂等之前，先看看有哪些操作是天然幂等的，以SQL为例。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tab1 <span class="keyword">set</span> col1 = <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>这样的更新语句，无论执行多少次结果都是不受影响的，所以是幂等的。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tab1 <span class="keyword">set</span> col1 = col1 + <span class="number">1</span> <span class="keyword">where</span> <span class="keyword">id</span> =<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>这样的更新语句会随着每次更新不断变化，所以不是幂等的。所以在考虑之前，先识别出幂等和非幂等操作。  </p>
<p>业务系统实现幂等的通用方式：一般是排重表校验，在业务操作所在的库建一张小表，名称暂时搞成dup_forbidden，核心字段就一个biz_id，并且在这个字段上建立一个unique index，其他字段可以根据业务需求来扩充。那么原来的业务f实现幂等的伪代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> <span class="keyword">transaction</span>;</span><br><span class="line">count = <span class="keyword">insert</span> <span class="keyword">ignore</span> dup_forbidden (...biz_id...) <span class="keyword">value</span>(...biz_id...)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  f(biz_id)</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p>可以认为这是一套业务系统实现幂等的模板做法，通过<a href="http://dev.mysql.com/doc/refman/5.5/en/insert.html" target="_blank" rel="noopener">insert</a> ignore返回值来判断是否已经执行过了，但是针对不同的情况可能还有变化。使用事务的目的是为了保证f和dup_forbidden的操作同时成功和失败。本质上来看，dup_forbidden表就是通过unique index来屏蔽对f的多次调用，事实上很多业务已经存在dup_forbidden表的功能。  </p>
<p>考虑如下场景：在一个面向交易的分布式应用中，支付子系统完成了支付功能，支付子系统通知订单子系统，通知的方式无非是调用订单子系统的一个函数f而已，只是调用的方式分为同步和异步。无论是同步还是异步，f都可能存在超时，所以为了支持重试，f必须是幂等的。f会首先根据传入的订单号来查找订单，检查订单状态。如果是已经支付，就会直接返回成功。如果是待支付状态，那么会尝试锁定（悲观锁和乐观锁）订单，修改状态，指定其他操作，其中锁定只是为了防止并发操作。伪代码实现如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> <span class="keyword">transaction</span>;</span><br><span class="line">count = <span class="keyword">update</span> deal_tab <span class="keyword">set</span> <span class="keyword">status</span> = paid <span class="keyword">where</span> <span class="keyword">id</span> = xx_id <span class="keyword">and</span> <span class="keyword">status</span> = unpaid</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  f(xx_id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<p>从这个例子可以看出deal_tab订单表本身已经可以作为dup_forbidden表的作用了，所以insert防重操作变成update来实现，当然这个是乐观锁的版本。悲观锁的版本如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span> <span class="keyword">transaction</span>;</span><br><span class="line">deal = <span class="keyword">select</span> * <span class="keyword">from</span> deal_tab <span class="keyword">where</span> <span class="keyword">id</span> = xx_id <span class="keyword">for</span> <span class="keyword">update</span></span><br><span class="line"><span class="keyword">if</span> (deal.status == paid) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; else if (deal.status = unpaid) &#123;</span><br><span class="line">  f(xx_id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p>
<p>当然基于悲观锁的做法对于高并发的系统是不建议的，毕竟长时间锁定记录会降低系统的TPS。  </p>
<p>当然，所有这些方案都是基于业务存在唯一的业务编号来设计实现的，可能会存在完全没有业务编号的吗？答案是it depends。即使没有完全唯一的编号，我们也可以人为生成编号，比如调用方负责生成调用编号，同一个调用编号发起的多次调用都被视为一次调用，既可以作为唯一键来排重。事实上，这种情况确实比较少！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>业务系统实现幂等性的方式基本确定。系统关键接口的幂等性为以后系统的长期发展，特别是往分布式方向发展打下了很好的根基，可以大大简化分布式应用的构建复杂度。</p>
<blockquote>
<p>转载 <a href="http://yongpoliu.com/idempotent/" target="_blank" rel="noopener">系统幂等以及常用实现方式</a></p>
</blockquote>
<h1 id="2016-10-21-20-54-46-康兴华"><a href="#2016-10-21-20-54-46-康兴华" class="headerlink" title="2016-10-21 20:54:46 康兴华"></a>2016-10-21 20:54:46 康兴华</h1><p>我认为幂等性的核心在于重试或重复请求的时候服务器如何判断是同一请求，一般就是在调用f方法的之前,先生成一个ticket（最好能区分时间先后用时间戳），后面调用的时候将ticket以参数的形式传递给服务器，在服务器端用用数据库表字段unique index来屏蔽对f的多次调用。  </p>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一致性哈希算法的理解与实践(Java)]]></title>
      <url>http://kxh.ink/2016/10/26/Consistent-Hashing/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在维基百科中，是这么定义的</p>
<blockquote>
<p>一致哈希是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。<br><a id="more"></a></p>
</blockquote>
<h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><p>我们在上文中已经介绍了一致性Hash算法的基本优势，我们看到了该算法主要解决的问题是：当slot数发生变化时，能够尽量少的移动数据。那么，我们思考一下，普通的Hash算法是如何实现？又存在什么问题呢？<br>那么我们引出一个问题：</p>
<blockquote>
<p>假设有1000w个数据项，100个存储节点，请设计一种算法合理地将他们存储在这些节点上。  </p>
</blockquote>
<p>看一看普通Hash算法的原理：<br><img src="fe155f98-3a5e-11e6-834d-193e6f85afcd.png" alt=""></p>
<p>算法的核心计算如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2016/10/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalHash</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer ITEMS = <span class="number">10000000</span>;</span><br><span class="line">        Integer NODES = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        Integer[] node_stat = <span class="keyword">new</span> Integer[NODES];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; ITEMS; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = hash(i.toString());</span><br><span class="line">            <span class="keyword">int</span> n = h % NODES;</span><br><span class="line">            <span class="keyword">if</span> (node_stat[n] == <span class="keyword">null</span>)</span><br><span class="line">                node_stat[n] = <span class="number">0</span>;</span><br><span class="line">            node_stat[n] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _ave = ITEMS / NODES;</span><br><span class="line">        <span class="keyword">int</span> _max = Collections.max(Arrays.asList(node_stat));</span><br><span class="line">        <span class="keyword">int</span> _min = Collections.min(Arrays.asList(node_stat));</span><br><span class="line">        System.out.printf(<span class="string">"Ave: %d%n"</span>, _ave);</span><br><span class="line">        System.out.printf(<span class="string">"Max: %d\t(%.2f%%)%n"</span>, _max, (_max - _ave) * <span class="number">100.0</span> / _ave);</span><br><span class="line">        System.out.printf(<span class="string">"Min: %d\t(%.2f%%)%n"</span>, _min, (_ave - _min) * <span class="number">100.0</span> / _ave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Ave: 100000<br>Max: 100653   (0.65%)<br>Min: 99160    (0.84%)</p>
</blockquote>
<p>从上述结果可以发现，普通的Hash算法均匀地将这些数据项打散到了这些节点上，并且分布最少和最多的存储节点数据项数目小于1%。之所以分布均匀，主要是依赖Hash算法能够比较随机的分布。</p>
<p>然而，我们看看存在一个问题，由于该算法使用节点数取余的方法，强依赖node的数目，因此，当是node数发生变化的时候，item所对应的node发生剧烈变化，而发生变化的成本就是我们需要在node数发生变化的时候，数据需要迁移，这对存储产品来说显然是不能忍的，我们观察一下增加node后，数据项移动的情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2016/10/26.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalHashAdd</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer ITEMS = <span class="number">10000000</span>;</span><br><span class="line">        Integer NODES = <span class="number">100</span>;</span><br><span class="line">        Integer NEW_NODES = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">        Integer change = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; ITEMS; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = hash(i.toString());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> n = h % NODES;</span><br><span class="line">            <span class="keyword">int</span> n_new = h % NEW_NODES;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n_new != n)</span><br><span class="line">                change += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Change: %d\t(%.2f%%)%n"</span>, change, change * <span class="number">100.0</span> / ITEMS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Change: 9900492   (99.00%)</p>
</blockquote>
<p>翻译一下就是，<strong>如果有100个item，当增加一个node，之前99%的数据都需要重新移动。</strong>  </p>
<p>这显然是不能忍的，普通哈希算法的问题我们已经发现了，如何对其进行改进呢？没错，我们的一致性哈希算法闪亮登场。  </p>
<h2 id="登场"><a href="#登场" class="headerlink" title="登场"></a>登场</h2><p>我们上节介绍了普通Hash算法的劣势，即当node数发生变化（增加、移除）后，数据项会被重新“打散”，导致大部分数据项不能落到原来的节点上，从而导致大量数据需要迁移。<br>那么，一个亟待解决的问题就变成了：当node数发生变化时，如何保证尽量少引起迁移呢？即<strong>当增加或者删除节点时，对于大多数item，保证原来分配到的某个node，现在仍然应该分配到那个node，将数据迁移量的降到最低。</strong>  </p>
<p>一致性Hash算法的原理是这样的：</p>
<p><img src="0e8fea32-3a5f-11e6-84b5-ff101495cf49.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mycommon.hash.Utils.hash;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2016/10/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistHashAdd</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer ITEMS = <span class="number">10000000</span>;</span><br><span class="line">        Integer NODES = <span class="number">100</span>;</span><br><span class="line">        Integer NEW_NODES = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ring = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; new_ring = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Integer change = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; NODES; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = hash(i.toString());</span><br><span class="line">            ring.add(h);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(ring);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; NEW_NODES; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = hash(i.toString());</span><br><span class="line">            new_ring.add(h);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(new_ring);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; ITEMS; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = hash(i.toString());</span><br><span class="line">            <span class="keyword">int</span> n = bisectLeft(ring, h) % NODES;</span><br><span class="line">            <span class="keyword">int</span> n_new = bisectLeft(new_ring, h) % NEW_NODES;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n_new != n)</span><br><span class="line">                change += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Change: %d\t(%.2f%%)%n"</span>, change, change * <span class="number">100.0</span> / ITEMS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bisectLeft</span><span class="params">(List&lt;Integer&gt; list, Integer key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = Math.min(list.size(), Math.abs(Collections.binarySearch(list, key)));</span><br><span class="line">        <span class="keyword">while</span> (idx &gt; <span class="number">0</span> &amp;&amp; list.get(idx - <span class="number">1</span>) &gt;= key) &#123;</span><br><span class="line">            idx--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们依然对其进行了实现ConsistHashAdd.java，并且观察了数据迁移的结果：</p>
<blockquote>
<p>Change: 6379941   (63.80%)</p>
</blockquote>
<p>虽然一致性Hash算法解决了节点变化导致的数据迁移问题，但是，我们回过头来再看看数据项分布的均匀性，进行了一致性Hash算法的实现ConsistHash.java：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.bisectLeft;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2016/10/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistHash</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer ITEMS = <span class="number">10000000</span>;</span><br><span class="line">        Integer NODES = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ring = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Integer[] node_stat = <span class="keyword">new</span> Integer[NODES];</span><br><span class="line">        Map&lt;Integer, Integer&gt; hash2node = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; NODES; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = hash(i.toString());</span><br><span class="line">            ring.add(h);</span><br><span class="line">            hash2node.put(h, i);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(ring);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; ITEMS; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = hash(i.toString());</span><br><span class="line">            <span class="keyword">int</span> n = bisectLeft(ring, h) % NODES;</span><br><span class="line">            <span class="keyword">if</span> (node_stat[hash2node.get(ring.get(n))] == <span class="keyword">null</span>)</span><br><span class="line">                node_stat[hash2node.get(ring.get(n))] = <span class="number">0</span>;</span><br><span class="line">            node_stat[hash2node.get(ring.get(n))] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _ave = ITEMS / NODES;</span><br><span class="line">        <span class="keyword">int</span> _max = Collections.max(Arrays.asList(node_stat));</span><br><span class="line">        <span class="keyword">int</span> _min = Collections.min(Arrays.asList(node_stat));</span><br><span class="line">        System.out.printf(<span class="string">"Ave: %d%n"</span>, _ave);</span><br><span class="line">        System.out.printf(<span class="string">"Max: %d\t(%.2f%%)%n"</span>, _max, (_max - _ave) * <span class="number">100.0</span> / _ave);</span><br><span class="line">        System.out.printf(<span class="string">"Min: %d\t(%.2f%%)%n"</span>, _min, (_ave - _min) * <span class="number">100.0</span> / _ave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Ave: 100000<br>Max: 636147 (536.15%)<br>Min: 2423   (97.58%)</p>
<p>这结果简直是简直了，确实非常结果差，分配的很不均匀。我们思考一下，一致性哈希算法分布不均匀的原因是什么？从最初的1000w个数据项经过一般的哈希算法的模拟来看，这些数据项“打散”后，是可以比较均匀分布的。但是引入一致性哈希算法后，为什么就不均匀呢？数据项本身的哈希值并未发生变化，变化的是判断数据项哈希应该落到哪个节点的算法变了。 </p>
<p><img src="8c9e6caa-3a5f-11e6-87ad-fdb462b76aef.png" alt=""></p>
<p>因此，主要是因为这100个节点Hash后，在环上分布不均匀，导致了每个节点实际占据环上的区间大小不一造成的。</p>
<h2 id="改进-虚节点"><a href="#改进-虚节点" class="headerlink" title="改进-虚节点"></a>改进-虚节点</h2><p>当我们将node进行哈希后，这些值并没有均匀地落在环上，因此，最终会导致，这些节点所管辖的范围并不均匀，最终导致了数据分布的不均匀。</p>
<p><img src="a0e32fde-3a5f-11e6-969d-085f64220e63.png" alt=""></p>
<p>详细实现请见VirtualConsistHash.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.bisectLeft;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2016/10/30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualConsistHash</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer ITEMS = <span class="number">10000000</span>;</span><br><span class="line">        Integer NODES = <span class="number">100</span>;</span><br><span class="line">        Integer VNODES = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ring = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Integer[] node_stat = <span class="keyword">new</span> Integer[NODES];</span><br><span class="line">        Map&lt;Integer, Integer&gt; hash2node = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NODES; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; VNODES; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = hash(String.valueOf(i) + String.valueOf(j));</span><br><span class="line">                ring.add(h);</span><br><span class="line">                hash2node.put(h, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(ring);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; ITEMS; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = hash(i.toString());</span><br><span class="line">            <span class="keyword">int</span> n = bisectLeft(ring, h) % (NODES * VNODES);</span><br><span class="line">            <span class="keyword">if</span> (node_stat[hash2node.get(ring.get(n))] == <span class="keyword">null</span>)</span><br><span class="line">                node_stat[hash2node.get(ring.get(n))] = <span class="number">0</span>;</span><br><span class="line">            node_stat[hash2node.get(ring.get(n))] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _ave = ITEMS / NODES;</span><br><span class="line">        <span class="keyword">int</span> _max = Collections.max(Arrays.asList(node_stat));</span><br><span class="line">        <span class="keyword">int</span> _min = Collections.min(Arrays.asList(node_stat));</span><br><span class="line">        System.out.printf(<span class="string">"Ave: %d%n"</span>, _ave);</span><br><span class="line">        System.out.printf(<span class="string">"Max: %d\t(%.2f%%)%n"</span>, _max, (_max - _ave) * <span class="number">100.0</span> / _ave);</span><br><span class="line">        System.out.printf(<span class="string">"Min: %d\t(%.2f%%)%n"</span>, _min, (_ave - _min) * <span class="number">100.0</span> / _ave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是这样的：</p>
<blockquote>
<p>Ave: 100000<br>Max: 117707   (17.71%)<br>Min: 9213 (90.79%)</p>
</blockquote>
<p>因此，通过增加虚节点的方法，使得每个节点在环上所“管辖”更加均匀。这样就既保证了在节点变化时，尽可能小的影响数据分布的变化，而同时又保证了数据分布的均匀。也就是靠增加“节点数量”加强管辖区间的均匀。<br>同时，观察增加节点后数据变动情况，详细的代码请见VirtualConsistHashAdd.java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.bisectLeft;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2016/10/30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VirtualConsistHashAdd</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer ITEMS = <span class="number">10000000</span>;</span><br><span class="line">        Integer NODES = <span class="number">100</span>;</span><br><span class="line">        Integer NEW_NODES = <span class="number">101</span>;</span><br><span class="line">        Integer VNODES = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ring = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; new_ring = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; hash2node = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; new_hash2node = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NODES; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; VNODES; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = hash(String.valueOf(i) + String.valueOf(j));</span><br><span class="line">                ring.add(h);</span><br><span class="line">                hash2node.put(h, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(ring);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NEW_NODES; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; VNODES; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> h = hash(String.valueOf(i) + String.valueOf(j));</span><br><span class="line">                new_ring.add(h);</span><br><span class="line">                new_hash2node.put(h, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(new_ring);</span><br><span class="line"></span><br><span class="line">        Integer change = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; ITEMS; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = hash(i.toString());</span><br><span class="line">            <span class="keyword">int</span> n = bisectLeft(ring, h) % (NODES * VNODES);</span><br><span class="line">            <span class="keyword">int</span> n_new = bisectLeft(new_ring, h) % (NEW_NODES * VNODES);</span><br><span class="line">            <span class="keyword">if</span> (hash2node.get(ring.get(n)) != new_hash2node.get(new_ring.get(n_new)))</span><br><span class="line">                change += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"Change: %d\t(%.2f%%)%n"</span>, change, change * <span class="number">100.0</span> / ITEMS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Change: 107545    (1.08%)</p>
</blockquote>
<h2 id="另一种改进"><a href="#另一种改进" class="headerlink" title="另一种改进"></a>另一种改进</h2><p>然而，虚节点这种靠数量取胜的策略增加了存储这些虚节点信息所需要的空间。在OpenStack的Swift组件中，使用了一种比较特殊的方法来解决分布不均的问题，改进了这些数据分布的算法，将环上的空间均匀的映射到一个线性空间，这样，就保证分布的均匀性。</p>
<p><img src="b01139ec-3a5f-11e6-965a-070f5c4c0afa.png" alt=""></p>
<p>代码实现见PartConsistHash.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.bisectLeft;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2016/10/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartConsistHash</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer ITEMS = <span class="number">10000000</span>;</span><br><span class="line">        Integer NODES = <span class="number">100</span>;</span><br><span class="line">        Integer LOG_NODE = <span class="number">7</span>;</span><br><span class="line">        Integer MAX_POWER = <span class="number">31</span>;<span class="comment">//这个值与原文不一样。如果是32的话有大部分的节点无法命中</span></span><br><span class="line">        Integer PARTITION = MAX_POWER - LOG_NODE;</span><br><span class="line">        Integer[] node_stat = <span class="keyword">new</span> Integer[NODES];</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ring = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; part2node = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.pow(<span class="number">2</span>, LOG_NODE); i++) &#123;</span><br><span class="line">            ring.add(i);</span><br><span class="line">            part2node.put(i, i % NODES);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NODES; i++) &#123;</span><br><span class="line">            node_stat[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; ITEMS; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = hash(i.toString()) &gt;&gt; PARTITION;</span><br><span class="line">            <span class="keyword">int</span> n = bisectLeft(ring, h) % NODES;</span><br><span class="line">            <span class="keyword">if</span> (node_stat[n] == <span class="keyword">null</span>)</span><br><span class="line">                node_stat[n] = <span class="number">0</span>;</span><br><span class="line">            node_stat[n] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _ave = ITEMS / NODES;</span><br><span class="line">        <span class="keyword">int</span> _max = Collections.max(Arrays.asList(node_stat));</span><br><span class="line">        <span class="keyword">int</span> _min = Collections.min(Arrays.asList(node_stat));</span><br><span class="line">        System.out.printf(<span class="string">"Ave: %d%n"</span>, _ave);</span><br><span class="line">        System.out.printf(<span class="string">"Max: %d\t(%.2f%%)%n"</span>, _max, (_max - _ave) * <span class="number">100.0</span> / _ave);</span><br><span class="line">        System.out.printf(<span class="string">"Min: %d\t(%.2f%%)%n"</span>, _min, (_ave - _min) * <span class="number">100.0</span> / _ave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Ave: 100000<br>Max: 157292   (57.29%)<br>Min: 77343    (22.66%)</p>
</blockquote>
<p>可以看到，数据分布是比较理想的。如果节点数刚好和分区数相等，理论上是可以均匀分布的。而观察下增加节点后的数据移动比例，代码实现见PartConsistHashAdd.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.bisectLeft;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.kxh.hash.Utils.hash;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2016/10/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartConsistHashAdd</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer ITEMS = <span class="number">10000000</span>;</span><br><span class="line">        Integer NODES = <span class="number">100</span>;</span><br><span class="line">        Integer NEW_NODES = <span class="number">101</span>;</span><br><span class="line">        Integer LOG_NODE = <span class="number">7</span>;</span><br><span class="line">        Integer MAX_POWER = <span class="number">31</span>;<span class="comment">//这个值与原文不一样。如果是32的话有大部分的节点无法命中</span></span><br><span class="line">        Integer PARTITION = MAX_POWER - LOG_NODE;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; ring = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; part2node = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; new_part2node = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.pow(<span class="number">2</span>, LOG_NODE); i++) &#123;</span><br><span class="line">            ring.add(i);</span><br><span class="line">            part2node.put(i, i % NODES);</span><br><span class="line">            new_part2node.put(i, i % NEW_NODES);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Integer change = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; ITEMS; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> h = hash(i.toString()) &gt;&gt; PARTITION;</span><br><span class="line">            <span class="keyword">int</span> p = bisectLeft(ring, h);</span><br><span class="line">            <span class="keyword">int</span> n = part2node.get(p) % NODES;</span><br><span class="line">            <span class="keyword">int</span> n_new = new_part2node.get(p) % NEW_NODES;</span><br><span class="line">            <span class="keyword">if</span> (n_new != n)</span><br><span class="line">                change += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">"Change: %d\t(%.2f%%)%n"</span>, change, change * <span class="number">100.0</span> / ITEMS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果如下所示：</p>
<blockquote>
<p>Change: 2185667   (21.86%)</p>
</blockquote>
<p>可以看到，移动也是比较理想的。</p>
<h2 id="hash和-bisectLeft-代码"><a href="#hash和-bisectLeft-代码" class="headerlink" title="hash和 bisectLeft 代码"></a>hash和 bisectLeft 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by KangXinghua on 2016/10/30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> p = <span class="number">16777619</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = (<span class="keyword">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">            hash = (hash ^ str.charAt(i)) * p;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果算出来的值为负数则取其绝对值</span></span><br><span class="line">        <span class="keyword">if</span> (hash &lt; <span class="number">0</span>)</span><br><span class="line">            hash = Math.abs(hash);</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bisectLeft</span><span class="params">(List&lt;Integer&gt; list, Integer key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = Math.min(list.size(), Math.abs(Collections.binarySearch(list, key)));</span><br><span class="line">        <span class="keyword">while</span> (idx &gt; <span class="number">0</span> &amp;&amp; list.get(idx - <span class="number">1</span>) &gt;= key) &#123;</span><br><span class="line">            idx--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>转载 <a href="http://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">一致性哈希算法的理解与实践</a> 修改了Python-&gt;Java</p>
</blockquote>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>代码的结果值和原文的不一样的主要原因是hash算法的不一样，原文的hash 是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_hash</span><span class="params">(value)</span>:</span></span><br><span class="line">    k = md5(str(value)).digest() </span><br><span class="line">    ha = unpack_from(<span class="string">"&gt;I"</span>, k)[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">return</span> ha</span><br></pre></td></tr></table></figure></p>
<p>我能力有限，没能翻译过来。</p>
]]></content>
      
        
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[言宜慢 心宜善]]></title>
      <url>http://kxh.ink/2016/10/01/YanYiMam-XinYiShan/</url>
      <content type="html"><![CDATA[<h1 id="言宜慢"><a href="#言宜慢" class="headerlink" title="言宜慢"></a>言宜慢</h1><p>　　“言宜慢”，是公元前77年王吉从七品知县调任昌邑王府中担任五品中尉时从一个老人那里得到的秘笈。昌邑王刘贺虽然是汉武帝的嫡孙，却荒淫无度喜怒无常，身边聚集的全是一些溜须拍马的小人。在这样险恶的官场中，王吉当然会感到非常忧愁。但幸运的是，他遇到了一个指点他走出迷津的老人，送给了他“言宜慢”3个字。凭借着这3个字，王吉居然渡过了一次次惊险，在官场上获得了很好的声誉，被汉宣帝刘询任命为谏议大夫，成了朝廷重臣。<br>　　说话，体现着一个人的智慧。特别是年轻人，由于人生经验不足，经常在说话上吃亏。《论语》中，孔子讲了这样一句话：“侍于君子有三愆：言未及之而言谓之躁，言及之而不言谓之隐，未见颜色而言谓之瞽。”<br>　　“言未及之而言，谓之躁”没轮到你讲话时，你抢着说，这就犯了“躁”的毛病。孔子一日曾与几位侍坐的弟子闲谈，让他们谈谈志向。子路性子急，孔子话音未落，他就洋洋洒洒地讲了一大套。可子路万万没想到，他这一通情感流露，却让孔子转身就赏了他一声冷笑，这热脸可是大大地贴上了凉屁股。<br>　　这就告诉我们，说话是一门艺术，一定要谨慎。历史上因为说错话而得罪人、甚至付出惨痛代价的人不胜枚举。言宜慢，就是告诉我们，说话要经过认真思虑再出口，这样可以让我们变得更加谨慎、稳重和冷静，练就我们成熟大气的人格；其次就是说话语调要舒缓，这样听的人才会感到受尊重、亲切，更舒服顺耳。<br><a id="more"></a></p>
<h1 id="心宜善"><a href="#心宜善" class="headerlink" title="心宜善"></a>心宜善</h1><p>　　“心宜善”，是王吉在公元前67年再度经过昌邑时老人送给他的3个字。原来，随着官位的升高，王吉出现了利用职权打击报复政敌的心理，将政敌整得很惨，害得很苦。比如说，长史赵珞，就因为与王吉政见不和，被王吉恶意弹劾，最后被罢官归乡，不久就郁郁而终。在老人的劝谏下，王吉痛改前非，不再整人害人，而是客观公正地对待每个人，受到了越来越多人的欢迎，在险恶的官场上一生顺利平安。而这个送给王吉六字秘诀的老人据称就是汉武帝时的著名宰相公孙弘。<br>　　心宜善，与人为善，必有福报。《孟子》上说，“君子以仁存心，以礼存心。仁者爱人，有礼者敬人。爱人者，人恒爱之；敬人者，人恒敬之。”心善的人，乐于助人，救人危难。周围的人都愿意与他交往，更愿意帮助他。《道德经》上说，天道无亲，常与善人。<br>　　心宜善，能生发人的阳气，我们中国文化有一句名言：“行善最乐”。四个字，大家都知道，平常看了这四个字，大家不大在意，因为把它看成是一个传统式的教条条文，把它当做鼓励人家的话。其实不是的，人的心理非常怪，我们做了任何一件不好的事，心理会不安、不快乐，内心不对劲，这个不安不对劲不是对别人，而是对自己，慢慢脸色神气都会变坏，精神弄走样了。假使你真正无条件绝对地行善，帮助人家，有利于人家，做了一件好事，心境自然非常快乐。那个快乐，不是道理上讲得出来的。<br>　　言宜慢，心宜善。为何这条家规仅仅6个字却有这么大的神奇力量呢？年轻时就该“言宜慢”，这样才能深思熟虑少犯错误，从而保护自己谋求发展。而人到壮年，心智成熟、实力雄厚，这时就应该“心宜善”。这样才能少树敌手，泱泱有长者风范，受人尊崇。<br>　　这六个字看似简单平淡，却饱含了古人做人做事的道理，从中我们能看到仁爱之心，进退之道。能做到这六个字，就拥有了成熟大气的人格。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
